(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-shape'), require('d3-selection'), require('d3-scale'), require('d3-path'), require('d3-array')) :
    typeof define === 'function' && define.amd ? define(['exports', 'd3-shape', 'd3-selection', 'd3-scale', 'd3-path', 'd3-array'], factory) :
    (global = global || self, factory(global.fc = global.fc || {}, global.d3, global.d3, global.d3, global.d3, global.d3));
}(this, function (exports, d3Shape, d3Selection, d3Scale, d3Path, d3Array) { 'use strict';

    var d3Shape__default = 'default' in d3Shape ? d3Shape['default'] : d3Shape;
    var d3Scale__default = 'default' in d3Scale ? d3Scale['default'] : d3Scale;

    // "Caution: avoid interpolating to or from the number zero when the interpolator is used to generate
    // a string (such as with attr).
    // Very small values, when stringified, may be converted to scientific notation and
    // cause a temporarily invalid attribute or style property value.
    // For example, the number 0.0000001 is converted to the string "1e-7".
    // This is particularly noticeable when interpolating opacity values.
    // To avoid scientific notation, start or end the transition at 1e-6,
    // which is the smallest value that is not stringified in exponential notation."
    // - https://github.com/mbostock/d3/wiki/Transitions#d3_interpolateNumber
    const effectivelyZero = 1e-6; // Wrapper around d3's selectAll/data data-join, which allows decoration of the result.
    // This is achieved by appending the element to the enter selection before exposing it.
    // A default transition of fade in/out is also implicitly added but can be modified.

    var dataJoin = ((element, className) => {
      element = element || 'g';

      let key = (_, i) => i;

      let explicitTransition = null;

      const dataJoin = function (container, data) {
        data = data || (d => d);

        const implicitTransition = container.selection ? container : null;

        if (implicitTransition) {
          container = container.selection();
        }

        const selected = container.selectAll((d, i, nodes) => Array.from(nodes[i].childNodes).filter(node => node.nodeType === 1)).filter(className == null ? element : `${element}.${className}`);
        let update = selected.data(data, key);
        const enter = update.enter().append(element).attr('class', className);
        let exit = update.exit(); // automatically merge in the enter selection

        update = update.merge(enter); // if transitions are enabled apply a default fade in/out transition

        const transition = implicitTransition || explicitTransition;

        if (transition) {
          update = update.transition(transition).style('opacity', 1);
          enter.style('opacity', effectivelyZero);
          exit = exit.transition(transition).style('opacity', effectivelyZero);
        }

        exit.remove();

        update.enter = () => enter;

        update.exit = () => exit;

        return update;
      };

      dataJoin.element = (...args) => {
        if (!args.length) {
          return element;
        }

        element = args[0];
        return dataJoin;
      };

      dataJoin.className = (...args) => {
        if (!args.length) {
          return className;
        }

        className = args[0];
        return dataJoin;
      };

      dataJoin.key = (...args) => {
        if (!args.length) {
          return key;
        }

        key = args[0];
        return dataJoin;
      };

      dataJoin.transition = (...args) => {
        if (!args.length) {
          return explicitTransition;
        }

        explicitTransition = args[0];
        return dataJoin;
      };

      return dataJoin;
    });

    var createReboundMethod = ((target, source, name) => {
      const method = source[name];

      if (typeof method !== 'function') {
        throw new Error(`Attempt to rebind ${name} which isn't a function on the source object`);
      }

      return (...args) => {
        var value = method.apply(source, args);
        return value === source ? target : value;
      };
    });

    var rebind = ((target, source, ...names) => {
      for (const name of names) {
        target[name] = createReboundMethod(target, source, name);
      }

      return target;
    });

    const createTransform = transforms => name => transforms.reduce((name, fn) => name && fn(name), name);

    var rebindAll = ((target, source, ...transforms) => {
      const transform = createTransform(transforms);

      for (const name of Object.keys(source)) {
        const result = transform(name);

        if (result) {
          target[result] = createReboundMethod(target, source, name);
        }
      }

      return target;
    });

    var regexify = (strsOrRegexes => strsOrRegexes.map(strOrRegex => typeof strOrRegex === 'string' ? new RegExp(`^${strOrRegex}$`) : strOrRegex));

    var exclude = ((...exclusions) => {
      exclusions = regexify(exclusions);
      return name => exclusions.every(exclusion => !exclusion.test(name)) && name;
    });

    var includeMap = (mappings => name => mappings[name]);

    var functor = (function (d) {
      return typeof d === 'function' ? d : function () {
        return d;
      };
    });

    // Checks that passed properties are 'defined', meaning that calling them with (d, i) returns non null values
    function defined() {
      var outerArguments = arguments;
      return function (d, i) {
        for (var c = 0, j = outerArguments.length; c < j; c++) {
          if (outerArguments[c](d, i) == null) {
            return false;
          }
        }

        return true;
      };
    }

    // determines the offset required along the cross scale based
    // on the series alignment
    var alignOffset = (function (align, width) {
      switch (align) {
        case 'left':
          return width / 2;

        case 'right':
          return -width / 2;

        default:
          return 0;
      }
    });

    var createBase = (function (initialValues) {
      var env = Object.assign({}, initialValues);

      var base = function base() {};

      Object.keys(env).forEach(function (key) {
        base[key] = function () {
          if (!arguments.length) {
            return env[key];
          }

          env[key] = arguments.length <= 0 ? undefined : arguments[0];
          return base;
        };
      });
      return base;
    });

    var xyBase = (function () {
      var baseValue = function baseValue() {
        return 0;
      };

      var crossValue = function crossValue(d) {
        return d.x;
      };

      var mainValue = function mainValue(d) {
        return d.y;
      };

      var align = 'center';

      var bandwidth = function bandwidth() {
        return 5;
      };

      var orient = 'vertical';
      var base = createBase({
        decorate: function decorate() {},
        defined: function defined$1(d, i) {
          return defined(baseValue, crossValue, mainValue)(d, i);
        },
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity()
      });

      base.values = function (d, i) {
        var width = bandwidth(d, i);
        var offset = alignOffset(align, width);
        var xScale = base.xScale();
        var yScale = base.yScale();

        if (orient === 'vertical') {
          var y = yScale(mainValue(d, i), i);
          var y0 = yScale(baseValue(d, i), i);
          var x = xScale(crossValue(d, i), i) + offset;
          return {
            d: d,
            x: x,
            y: y,
            y0: y0,
            width: width,
            height: y - y0,
            origin: [x, y],
            baseOrigin: [x, y0],
            transposedX: x,
            transposedY: y
          };
        } else {
          var _y = xScale(mainValue(d, i), i);

          var _y2 = xScale(baseValue(d, i), i);

          var _x = yScale(crossValue(d, i), i) + offset;

          return {
            d: d,
            x: _x,
            y: _y,
            y0: _y2,
            width: width,
            height: _y - _y2,
            origin: [_y, _x],
            baseOrigin: [_y2, _x],
            transposedX: _y,
            transposedY: _x
          };
        }
      };

      base.xValues = function () {
        return orient === 'vertical' ? [crossValue] : [baseValue, mainValue];
      };

      base.yValues = function () {
        return orient !== 'vertical' ? [crossValue] : [baseValue, mainValue];
      };

      base.baseValue = function () {
        if (!arguments.length) {
          return baseValue;
        }

        baseValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.crossValue = function () {
        if (!arguments.length) {
          return crossValue;
        }

        crossValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.mainValue = function () {
        if (!arguments.length) {
          return mainValue;
        }

        mainValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.bandwidth = function () {
        if (!arguments.length) {
          return bandwidth;
        }

        bandwidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.align = function () {
        if (!arguments.length) {
          return align;
        }

        align = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.orient = function () {
        if (!arguments.length) {
          return orient;
        }

        orient = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      return base;
    });

    var red = '#c60';
    var green = '#6c0';
    var black = '#000';
    var gray = '#ddd';
    var darkGray = '#999';
    var colors = {
      red: red,
      green: green,
      black: black,
      gray: gray,
      darkGray: darkGray
    };

    var line = (function () {
      var base = xyBase();
      var lineData = d3Shape.line().x(function (d, i) {
        return base.values(d, i).transposedX;
      }).y(function (d, i) {
        return base.values(d, i).transposedY;
      });
      var join = dataJoin('path', 'line');

      var line = function line(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        lineData.defined(base.defined());
        selection.each(function (data, index, group) {
          var path = join(d3Selection.select(group[index]), [data]);
          path.enter().attr('fill', 'none').attr('stroke', colors.black);
          path.attr('d', lineData);
          base.decorate()(path, data, index);
        });
      };

      rebindAll(line, base, exclude('baseValue', 'bandwidth', 'align'));
      rebind(line, join, 'key');
      rebind(line, lineData, 'curve');
      return line;
    });

    var line$1 = (function () {
      var base = xyBase();
      var lineData = d3Shape.line().x(function (d, i) {
        return base.values(d, i).transposedX;
      }).y(function (d, i) {
        return base.values(d, i).transposedY;
      });

      var line = function line(data) {
        var context = lineData.context();
        context.beginPath();
        context.strokeStyle = colors.black;
        context.fillStyle = 'transparent';
        base.decorate()(context, data);
        lineData.defined(base.defined())(data);
        context.fill();
        context.stroke();
        context.closePath();
      };

      rebindAll(line, base, exclude('baseValue', 'bandwidth', 'align'));
      rebind(line, lineData, 'curve', 'context');
      return line;
    });

    var isIdentityScale = (function (scale) {
      return scale.copy.toString() === d3Scale__default.scaleIdentity().copy.toString();
    });

    var baseScale = (() => {
      let domain = [0, 1];
      let range = [-1, 1];

      const base = () => {};

      base.domain = (...args) => {
        if (!args.length) {
          return domain;
        }

        domain = args[0];
        return base;
      };

      base.range = (...args) => {
        if (!args.length) {
          return range;
        }

        range = args[0];
        return base;
      };

      return base;
    });

    var bufferBuilder = (() => {
      const attributes = {};
      const uniforms = {};
      let elementIndices = null;

      const bufferBuilder = (programBuilder, program) => {
        const gl = programBuilder.context();
        Object.keys(attributes).forEach(name => {
          const attribute = attributes[name];

          if (typeof attribute !== 'function') {
            throw new Error(`Expected an attribute for ${name}, found ${attribute}`);
          }

          const location = gl.getAttribLocation(program, name);
          attribute.location(location)(programBuilder);
        });
        Object.keys(uniforms).forEach(name => {
          const uniform = uniforms[name];

          if (typeof uniform !== 'function') {
            throw new Error(`Expected a uniform for ${name}, found ${uniform}`);
          }

          const location = gl.getUniformLocation(program, name);
          uniform.location(location)(programBuilder);
        });

        if (elementIndices !== null) {
          elementIndices(programBuilder);
        }
      };

      bufferBuilder.attribute = (...args) => {
        if (args.length === 1) {
          return attributes[args[0]];
        }

        attributes[args[0]] = args[1];
        return bufferBuilder;
      };

      bufferBuilder.uniform = (...args) => {
        if (args.length === 1) {
          return uniforms[args[0]];
        }

        uniforms[args[0]] = args[1];
        return bufferBuilder;
      };

      bufferBuilder.elementIndices = (...args) => {
        if (!args.length) {
          return elementIndices;
        }

        elementIndices = args[0];
        return bufferBuilder;
      };

      return bufferBuilder;
    });

    var uniform = (initialData => {
      let location = -1;
      let data = initialData;
      let dirty = true;

      const build = programBuilder => {
        if (!dirty) {
          return;
        }

        const gl = programBuilder.context();

        if (Array.isArray(data)) {
          switch (data.length) {
            case 1:
              gl.uniform1fv(location, data);
              break;

            case 2:
              gl.uniform2fv(location, data);
              break;

            case 3:
              gl.uniform3fv(location, data);
              break;

            case 4:
              gl.uniform4fv(location, data);
              break;

            default:
              throw new Error(`Uniform supports up to 4 elements. ${data.length} provided.`);
          }
        } else {
          gl.uniform1f(location, data);
        }

        dirty = false;
      };

      build.location = (...args) => {
        if (!args.length) {
          return location;
        }

        if (location !== args[0]) {
          location = args[0];
          dirty = true;
        }

        return build;
      };

      build.data = (...args) => {
        if (!args.length) {
          return data;
        }

        data = args[0];
        dirty = true;
        return build;
      };

      return build;
    });

    var drawModes = {
      POINTS: 0,
      LINES: 1,
      LINE_LOOP: 2,
      LINE_STRIP: 3,
      TRIANGLES: 4,
      TRIANGLE_STRIP: 5,
      TRIANGLE_FAN: 6
    };

    var programBuilder = (() => {
      let context = null;
      let program = null;
      let vertexShader = null;
      let fragmentShader = null;
      let mode = drawModes.TRIANGLES;
      let buffers = bufferBuilder();

      const build = count => {
        const vertexShaderSource = vertexShader();
        const fragmentShaderSource = fragmentShader();

        if (newProgram(program, vertexShaderSource, fragmentShaderSource)) {
          context.isProgram(program) && context.deleteProgram(program);
          program = createProgram(vertexShaderSource, fragmentShaderSource);
        }

        context.useProgram(program);
        buffers.uniform('uScreen', uniform([context.canvas.width, context.canvas.height]));
        buffers(build, program);
        var ext = context.getExtension('ANGLE_instanced_arrays');

        if (mode !== drawModes.POINTS && mode !== drawModes.TRIANGLES) {
          throw Error(`Expected mode TRIANGLES (${drawModes.TRIANGLES}) or POINTS (${drawModes.POINTS}). ${mode} received instead.`);
        }

        if (buffers.elementIndices() == null) {
          throw Error('Element indices must be provided.');
        }

        ext.drawElementsInstancedANGLE(mode, buffers.elementIndices().data().length, context.UNSIGNED_SHORT, 0, count);
      };

      build.context = (...args) => {
        if (!args.length) {
          return context;
        }

        context = args[0];
        return build;
      };

      build.buffers = (...args) => {
        if (!args.length) {
          return buffers;
        }

        buffers = args[0];
        return build;
      };

      build.vertexShader = (...args) => {
        if (!args.length) {
          return vertexShader;
        }

        vertexShader = args[0];
        return build;
      };

      build.fragmentShader = (...args) => {
        if (!args.length) {
          return fragmentShader;
        }

        fragmentShader = args[0];
        return build;
      };

      build.mode = (...args) => {
        if (!args.length) {
          return mode;
        }

        mode = args[0];
        return build;
      };

      return build;

      function newProgram(program, vertexShader, fragmentShader) {
        if (!program) {
          return true;
        }

        const shaders = context.getAttachedShaders(program);
        const vertexShaderSource = context.getShaderSource(shaders[0]);
        const fragmentShaderSource = context.getShaderSource(shaders[1]);
        return vertexShader !== vertexShaderSource || fragmentShader !== fragmentShaderSource;
      }

      function createProgram(vertexShaderSource, fragmentShaderSource) {
        const vertexShader = loadShader(vertexShaderSource, context.VERTEX_SHADER);
        const fragmentShader = loadShader(fragmentShaderSource, context.FRAGMENT_SHADER);
        const program = context.createProgram();
        context.attachShader(program, vertexShader);
        context.attachShader(program, fragmentShader);
        context.linkProgram(program);

        if (!context.getProgramParameter(program, context.LINK_STATUS)) {
          const message = context.getProgramInfoLog(program);
          context.deleteProgram(program);
          throw new Error(`Failed to link program : ${message}
            Vertex Shader : ${vertexShaderSource}
            Fragment Shader : ${fragmentShaderSource}`);
        }

        return program;
      }

      function loadShader(source, type) {
        const shader = context.createShader(type);
        context.shaderSource(shader, source);
        context.compileShader(shader);

        if (!context.getShaderParameter(shader, context.COMPILE_STATUS)) {
          const message = context.getShaderInfoLog(shader);
          context.deleteShader(shader);
          throw new Error(`Failed to compile shader : ${message}
            Shader : ${source}`);
        }

        return shader;
      }
    });

    var shaderBuilder = (base => {
      const shaderHeaders = [];
      const shaderBodies = [];

      const build = () => {
        return base(shaderHeaders.join('\n'), shaderBodies.join('\n'));
      };

      function append(array, element) {
        array.push(element);
      }

      function insert(array, element, before) {
        const beforeIndex = array.indexOf(before);
        array.splice(beforeIndex >= 0 ? beforeIndex : array.length, 0, element);
      }

      function appendIfNotExists(array, element) {
        const elementIndex = array.indexOf(element);

        if (elementIndex === -1) {
          array.push(element);
        }
      }

      build.appendHeader = header => {
        append(shaderHeaders, header);
        return build;
      };

      build.insertHeader = (header, before) => {
        insert(shaderHeaders, header, before);
        return build;
      };

      build.appendHeaderIfNotExists = header => {
        appendIfNotExists(shaderHeaders, header);
        return build;
      };

      build.appendBody = body => {
        append(shaderBodies, body);
        return build;
      };

      build.insertBody = (body, before) => {
        insert(shaderBodies, body, before);
        return build;
      };

      build.appendBodyIfNotExists = body => {
        appendIfNotExists(shaderBodies, body);
        return build;
      };

      return build;
    }); // inf is precalculated here for use in some functions (e.g. log scale calculations)

    const vertexShaderBase = (header, body) => `
precision mediump float;
float inf = 1.0 / 0.0;
${header}
void main() {
    ${body}
}`;
    const fragmentShaderBase = (header, body) => `
precision mediump float;
${header}
void main() {
    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    ${body}
}`;

    const circle = {
      header: `
        attribute float aCrossValue;
        attribute float aMainValue;
        attribute float aSize;
        attribute float aDefined;

        uniform float uStrokeWidth;

        varying float vSize;
        varying float vDefined;`,
      body: `
        vDefined = aDefined;
        vSize = 2.0 * sqrt(aSize / 3.14159);
        gl_PointSize = vSize + uStrokeWidth + 1.0;
        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);`
    };
    const square = {
      header: `
        attribute float aCrossValue;
        attribute float aMainValue;
        attribute float aSize;
        attribute float aDefined;

        uniform float uStrokeWidth;

        varying float vSize;
        varying float vDefined;`,
      body: `
        vDefined = aDefined;
        vSize = sqrt(aSize);
        gl_PointSize = vSize + uStrokeWidth + 1.0;
        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);`
    };
    const triangle = {
      header: `
        attribute float aCrossValue;
        attribute float aMainValue;
        attribute float aSize;
        attribute float aDefined;

        uniform float uStrokeWidth;

        varying float vSize;
        varying float vDefined;`,
      body: `
        vDefined = aDefined;
        vSize = sqrt((16.0 * aSize) / (3.0 * sqrt(3.0)));
        gl_PointSize = vSize + uStrokeWidth + 1.0;
        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);`
    };
    const cross = {
      header: `
        attribute float aCrossValue;
        attribute float aMainValue;
        attribute float aSize;
        attribute float aDefined;

        uniform float uStrokeWidth;

        varying float vSize;
        varying float vStrokeWidthRatio;
        varying float vDefined;`,
      body: `
        vDefined = aDefined;
        vSize = 3.0 * sqrt(aSize / 5.0);
        vStrokeWidthRatio = uStrokeWidth / (vSize + uStrokeWidth + 1.0);
        gl_PointSize = vSize + uStrokeWidth + 1.0;
        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);`
    };
    const candlestick = {
      header: `
        attribute float aCrossValue;
        attribute float aBandwidth;
        attribute float aHighValue;
        attribute float aOpenValue;
        attribute float aCloseValue;
        attribute float aLowValue;
        attribute vec3 aCorner;
        attribute float aDefined;
    
        uniform vec2 uScreen;
        uniform float uStrokeWidth;
        
        varying float vColorIndicator;
        varying float vDefined;`,
      body: `
        vDefined = aDefined;
        vColorIndicator = sign(aCloseValue - aOpenValue);

        float isPositiveY = (sign(aCorner.y) + 1.0) / 2.0;
        float isNotPositiveY = 1.0 - isPositiveY;
        float isExtremeY = abs(aCorner.y) - 1.0;
        float isNotExtremeY = 1.0 - isExtremeY;
        float yValue =
         (isPositiveY * isExtremeY * aLowValue) + 
         (isPositiveY * isNotExtremeY * aCloseValue) +
         (isNotPositiveY * isNotExtremeY * aOpenValue) +
         (isNotPositiveY * isExtremeY * aHighValue);

        float lineWidthXDirection = (isNotExtremeY * aCorner.x) + (isExtremeY * aCorner.z);
        float lineWidthYDirection = isNotExtremeY * sign(aCloseValue - aOpenValue) * aCorner.y;

        float bandwidthModifier = aBandwidth * aCorner.x / 2.0;

        float xModifier = (uStrokeWidth * lineWidthXDirection / 2.0) + bandwidthModifier;
        float yModifier = uStrokeWidth * lineWidthYDirection / 2.0;

        gl_Position = vec4(aCrossValue, yValue, 0, 1);`
    };
    const ohlc = {
      header: `
        attribute float aCrossValue;
        attribute float aBandwidth;
        attribute float aHighValue;
        attribute float aOpenValue;
        attribute float aCloseValue;
        attribute float aLowValue;
        attribute vec3 aCorner;
        attribute float aDefined;

        uniform vec2 uScreen;
        uniform float uStrokeWidth;

        varying float vColorIndicator;
        varying float vDefined;`,
      body: `
        vDefined = aDefined;
        vColorIndicator = sign(aCloseValue - aOpenValue);

        float isPositiveY = (sign(aCorner.y) + 1.0) / 2.0;
        float isNotPositiveY = 1.0 - isPositiveY;
        float isExtremeY = abs(aCorner.y) - 1.0;
        float isNotExtremeY = 1.0 - isExtremeY;
        float yValue = 
            (isPositiveY * isExtremeY * aLowValue) + 
            (isPositiveY * isNotExtremeY * aCloseValue) +
            (isNotPositiveY * isNotExtremeY * aOpenValue) +
            (isNotPositiveY * isExtremeY * aHighValue);

        float lineWidthXDirection = isExtremeY * aCorner.z;
        float lineWidthYDirection = isNotExtremeY * aCorner.z;

        float bandwidthModifier = isNotExtremeY * aCorner.x * aBandwidth / 2.0;

        float xModifier = (uStrokeWidth * lineWidthXDirection / 2.0) + bandwidthModifier;
        float yModifier = uStrokeWidth * lineWidthYDirection / 2.0;

        gl_Position = vec4(aCrossValue, yValue, 0, 1);`
    };
    const bar = {
      header: `
        attribute float aCrossValue;
        attribute float aBandwidth;
        attribute float aMainValue;
        attribute float aBaseValue;
        attribute vec2 aCorner;
        attribute float aDefined;
        
        uniform vec2 uScreen;
        uniform float uStrokeWidth;
        
        varying float vDefined;`,
      body: `
        vDefined = aDefined;
        float isBaseline = (1.0 - aCorner.y) / 2.0;
        float yValue = (isBaseline * aBaseValue) + ((1.0 - isBaseline) * aMainValue);

        float xModifier = aCorner.x * (aBandwidth) / 2.0;

        gl_Position = vec4(aCrossValue, yValue, 0, 1);`
    };
    const preScaleLine = {
      header: `
        attribute vec3 aCorner;
        attribute float aCrossNextValue;
        attribute float aMainNextValue;
        attribute float aCrossValue;
        attribute float aMainValue;
        attribute float aCrossPrevValue;
        attribute float aMainPrevValue;
        attribute float aCrossPrevPrevValue;
        attribute float aMainPrevPrevValue;
        attribute float aDefined;
        attribute float aDefinedNext;
        
        uniform float uStrokeWidth;
        uniform vec2 uScreen;

        varying float vDefined;`,
      body: `
        vDefined = aDefined * aDefinedNext;
        vec4 next = vec4(aCrossNextValue, aMainNextValue, 0, 0);
        gl_Position = vec4(aCrossValue, aMainValue, 0, 1);
        vec4 prev = vec4(aCrossPrevValue, aMainPrevValue, 0, 0);
        vec4 prevPrev = vec4(aCrossPrevPrevValue, aMainPrevPrevValue, 0, 0);`
    };
    const postScaleLine = {
      body: `
        vec4 prevVertexPosition = gl_Position;
        vec4 currVertexPosition = gl_Position;
        
        if (all(equal(prev.xy, prevPrev.xy))) {
            prevPrev.xy = prev.xy + normalize(prev.xy - prevVertexPosition.xy);
        }
        if (all(equal(prev.xy, prevVertexPosition.xy))) {
            prevVertexPosition.xy = prev.xy + normalize(prev.xy - prevPrev.xy);
        }
        vec2 A = normalize(normalize(prev.xy - prevPrev.xy) * uScreen);
        vec2 B = normalize(normalize(prevVertexPosition.xy - prev.xy) * uScreen);
        vec2 tangent = normalize(A + B);
        vec2 miter = vec2(-tangent.y, tangent.x);
        vec2 normalA = vec2(-A.y, A.x);
        float miterLength = 1.0 / dot(miter, normalA);
        vec2 point = normalize(A - B);
        if (miterLength > 10.0 && sign(aCorner.x * dot(miter, point)) > 0.0) {
            prevVertexPosition.xy = prev.xy - (aCorner.x * aCorner.y * uStrokeWidth * normalA) / uScreen.xy;
        } else {
            prevVertexPosition.xy = prev.xy + (aCorner.x * miter * uStrokeWidth * miterLength) / uScreen.xy;
        }

        if (all(equal(currVertexPosition.xy, prev.xy))) {
            prev.xy = currVertexPosition.xy + normalize(currVertexPosition.xy - next.xy);
        }
        if (all(equal(currVertexPosition.xy, next.xy))) {
            next.xy = currVertexPosition.xy + normalize(currVertexPosition.xy - prev.xy);
        }
        vec2 C = normalize(normalize(currVertexPosition.xy - prev.xy) * uScreen);
        vec2 D = normalize(normalize(next.xy - currVertexPosition.xy) * uScreen);
        vec2 tangentCD = normalize(C + D);
        vec2 miterCD = vec2(-tangentCD.y, tangentCD.x);
        vec2 normalC = vec2(-C.y, C.x);
        float miterCDLength = 1.0 / dot(miterCD, normalC);
        vec2 pointCD = normalize(C - D);
        if (miterCDLength > 10.0 && sign(aCorner.x * dot(miterCD, pointCD)) > 0.0) {
            currVertexPosition.xy = currVertexPosition.xy - (aCorner.x * aCorner.y * uStrokeWidth * normalC) / uScreen.xy;
        } else {
            currVertexPosition.xy = currVertexPosition.xy + (aCorner.x * miterCD * uStrokeWidth * miterCDLength) / uScreen.xy;
        }
        
        gl_Position.xy = ((1.0 - aCorner.z) * prevVertexPosition.xy) + (aCorner.z * currVertexPosition.xy);`
    };
    const errorBar = {
      header: `
        attribute vec3 aCorner;
        attribute float aCrossValue;
        attribute float aBandwidth;
        attribute float aHighValue;
        attribute float aLowValue;
        attribute float aDefined;

        uniform vec2 uScreen;
        uniform float uStrokeWidth;
        
        varying float vDefined;`,
      body: `
        vDefined = aDefined;
        float isLow = (aCorner.y + 1.0) / 2.0;
        float yValue = isLow * aLowValue + (1.0 - isLow) * aHighValue;

        float isEdgeCorner = abs(aCorner.x);
        float lineWidthXDirection = (1.0 - isEdgeCorner) * aCorner.z;
        float lineWidthYDirection = isEdgeCorner * aCorner.z;
        
        gl_Position = vec4(aCrossValue, yValue, 0, 1);
        
        float xModifier = (uStrokeWidth * lineWidthXDirection) + (aBandwidth * aCorner.x / 2.0);
        float yModifier = (uStrokeWidth * lineWidthYDirection);`
    };
    const area = {
      header: `
        attribute vec3 aCorner;
        attribute float aCrossValue;
        attribute float aMainValue;
        attribute float aCrossPrevValue;
        attribute float aMainPrevValue;
        attribute float aBaseValue;
        attribute float aBasePrevValue;
        attribute float aDefined;
        attribute float aDefinedNext;

        varying float vDefined;
        
        float when_lt(float a, float b) {
            return max(sign(b - a), 0.0);
        }
        
        float and(float a, float b) {
            return a * b;
        }`,
      body: `
        vDefined = aDefined * aDefinedNext;
        gl_Position = vec4(0, 0, 0, 1);

        float hasIntercepted = when_lt((aMainValue - aBaseValue) * (aMainPrevValue - aBasePrevValue), 0.0);
        float useIntercept = and(aCorner.z, hasIntercepted);
        
        float yGradient = (aMainValue - aMainPrevValue) / (aCrossValue - aCrossPrevValue);
        float yConstant = aMainValue - (yGradient * aCrossValue);

        float y0Gradient = (aBaseValue - aBasePrevValue) / (aCrossValue - aCrossPrevValue);
        float y0Constant = aBaseValue - (y0Gradient * aCrossValue);

        float denominator = (yGradient - y0Gradient) + step(abs(yGradient - y0Gradient), 0.0);
        float interceptXValue = (y0Constant - yConstant) / denominator;
        float interceptYValue = (yGradient * interceptXValue) + yConstant;

        gl_Position = vec4(interceptXValue * useIntercept, interceptYValue * useIntercept, 0, 1);
        
        gl_Position.x += (1.0 - useIntercept) * ((aCorner.x * aCrossValue) + ((1.0 - aCorner.x) * aCrossPrevValue));
        gl_Position.y += (1.0 - useIntercept) * (1.0 - aCorner.y) * ((aCorner.x * aMainValue) + ((1.0 - aCorner.x) * aMainPrevValue));
        gl_Position.y += (1.0 - useIntercept) * aCorner.y * ((aCorner.x * aBaseValue) + ((1.0 - aCorner.x) * aBasePrevValue));`
    };
    const boxPlot = {
      header: `
        attribute vec4 aCorner;
        attribute float aCrossValue;
        attribute float aBandwidth;
        attribute float aCapWidth;
        attribute float aHighValue;
        attribute float aUpperQuartileValue;
        attribute float aMedianValue;
        attribute float aLowerQuartileValue;
        attribute float aLowValue;
        attribute float aDefined;

        uniform vec2 uScreen;
        uniform float uStrokeWidth;
        
        varying float vDefined;`,
      body: `
        vDefined = aDefined;
        float isExtremeY = sign(abs(aCorner.y) - 2.0) + 1.0;
        float isNotExtremeY = 1.0 - isExtremeY;

        float isNonZeroY = abs(sign(aCorner.y));
        float isZeroY = 1.0 - isNonZeroY;

        float isQuartileY = isNotExtremeY * isNonZeroY;

        float isPositiveY = (sign(aCorner.y + 0.5) + 1.0) / 2.0;
        float isNegativeY = 1.0 - isPositiveY;

        float yValue =
          (isExtremeY * isNegativeY) * aHighValue +
          (isQuartileY * isNegativeY) * aUpperQuartileValue +
          isZeroY * aMedianValue +
          (isQuartileY * isPositiveY) * aLowerQuartileValue +
          (isExtremeY * isPositiveY) * aLowValue;

        gl_Position = vec4(aCrossValue, yValue, 0, 1);

        float isHorizontal = aCorner.w;
        float isVertical = 1.0 - isHorizontal;

        float xDisplacement = aCorner.x * (isExtremeY * aCapWidth + isNotExtremeY * aBandwidth) / 2.0;
        
        float xModifier = (isVertical * uStrokeWidth * aCorner.z / 2.0) + xDisplacement;
        float yModifier = isHorizontal * uStrokeWidth * aCorner.z / 2.0;`
    };

    const circle$1 = {
      header: `
        varying float vSize;
        varying float vDefined;`,
      body: `
        float distance = length(2.0 * gl_PointCoord - 1.0);
        if (distance > 1.0 || vDefined < 0.5) {
            discard;
            return;
        }`
    };
    const square$1 = {
      header: `
        varying float vSize;
        varying float vDefined;`,
      body: `
        if (vDefined < 0.5) {
            discard;
        }
        vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;
        float distance = max(abs(pointCoordTransform.x), abs(pointCoordTransform.y));`
    };
    const triangle$1 = {
      header: `
        varying float vSize;
        varying float vDefined;`,
      body: `
        vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;
        float topEdgesDistance = abs(pointCoordTransform.x) - ((pointCoordTransform.y - 0.6) / sqrt(3.0));
        float bottomEdgeDistance = pointCoordTransform.y + 0.5;
        float distance = max(topEdgesDistance, bottomEdgeDistance);
        if (distance > 1.0 || vDefined < 0.5) {
            discard;
        }`
    };
    const cross$1 = {
      header: `
        varying float vSize;
        varying float vStrokeWidthRatio;
        varying float vDefined;`,
      body: `
        vec2 pointCoordTransform = 2.0 * gl_PointCoord - 1.0;
        float innerCornerDistance = min(abs(pointCoordTransform.x), abs(pointCoordTransform.y)) + 0.66 - vStrokeWidthRatio;
        float outerEdgeDistance = max(abs(pointCoordTransform.x), abs(pointCoordTransform.y));
        float distance = max(innerCornerDistance, outerEdgeDistance);
        if (distance > 1.0 || vDefined < 0.5) {
            discard;
        }`
    };
    const candlestick$1 = {
      header: `
        varying float vColorIndicator;
        varying float vDefined;`,
      body: `
        if (vDefined < 0.5) {
            discard;
        }
        gl_FragColor = vec4(0.4, 0.8, 0, 1);
        if (vColorIndicator < 0.0) {
            gl_FragColor = vec4(0.8, 0.4, 0, 1);
        }`
    };
    const ohlc$1 = {
      header: `
        varying float vColorIndicator;
        varying float vDefined;`,
      body: `
        if (vDefined < 0.5) {
            discard;
        }
        gl_FragColor = vec4(0.4, 0.8, 0, 1);
        if (vColorIndicator < 0.0) {
            gl_FragColor = vec4(0.8, 0.4, 0, 1);
        }`
    };
    const area$1 = {
      header: `
        varying float vDefined;`,
      body: `if (vDefined < 0.5) {
            discard;
        }
        gl_FragColor = vec4(0.86, 0.86, 0.86, 1);`
    };
    const boxPlot$1 = {
      header: `varying float vDefined;`,
      body: `
        if (vDefined < 0.5) {
            discard;
        }`
    };
    const errorBar$1 = {
      header: `varying float vDefined;`,
      body: `
        if (vDefined < 0.5) {
            discard;
        }`
    };
    const bar$1 = {
      header: `varying float vDefined;`,
      body: `
        if (vDefined < 0.5) {
            discard;
        }`
    };
    const line$2 = {
      header: `varying float vDefined;`,
      body: `if (vDefined < 0.5) {
        discard;
    }`
    };

    var areaShader = (() => {
      const vertexShader = shaderBuilder(vertexShaderBase);
      const fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(area.header).appendBody(area.body);
      fragmentShader.appendHeader(area$1.header).appendBody(area$1.body);
      return {
        vertex: () => vertexShader,
        fragment: () => fragmentShader
      };
    });

    const types = {
      BYTE: 5120,
      UNSIGNED_BYTE: 5121,
      SHORT: 5122,
      UNSIGNED_SHORT: 5123,
      FLOAT: 5126
    };
    function length(type) {
      switch (type) {
        case types.BYTE:
        case types.UNSIGNED_BYTE:
          return 1;

        case types.SHORT:
        case types.UNSIGNED_SHORT:
          return 2;

        case types.FLOAT:
          return 4;

        default:
          throw new Error(`Unknown type ${type}`);
      }
    }
    function getArrayViewConstructor(type) {
      switch (type) {
        case types.BYTE:
          return Int8Array;

        case types.UNSIGNED_BYTE:
          return Uint8Array;

        case types.SHORT:
          return Int16Array;

        case types.UNSIGNED_SHORT:
          return Uint16Array;

        case types.FLOAT:
          return Float32Array;

        default:
          throw new Error(`Unknown type ${type}`);
      }
    }

    var baseAttributeBuilder = (() => {
      let location = -1;
      let buffer = null;
      let size = 1; // per vertex

      let type = types.FLOAT;
      let normalized = false;
      let stride = 0;
      let offset = 0;
      let divisor = 0;

      const baseAttribute = programBuilder => {
        const gl = programBuilder.context();

        if (buffer == null || !gl.isBuffer(buffer)) {
          buffer = gl.createBuffer();
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
        gl.enableVertexAttribArray(location);
        const ext = gl.getExtension('ANGLE_instanced_arrays');
        ext.vertexAttribDivisorANGLE(location, divisor);
      };

      baseAttribute.location = (...args) => {
        if (!args.length) {
          return location;
        }

        location = args[0];
        return baseAttribute;
      };

      baseAttribute.buffer = (...args) => {
        if (!args.length) {
          return buffer;
        }

        buffer = args[0];
        return baseAttribute;
      };

      baseAttribute.size = (...args) => {
        if (!args.length) {
          return size;
        }

        size = args[0];
        return baseAttribute;
      };

      baseAttribute.type = (...args) => {
        if (!args.length) {
          return type;
        }

        type = args[0];
        return baseAttribute;
      };

      baseAttribute.normalized = (...args) => {
        if (!args.length) {
          return normalized;
        }

        normalized = args[0];
        return baseAttribute;
      };

      baseAttribute.stride = (...args) => {
        if (!args.length) {
          return stride;
        }

        stride = args[0];
        return baseAttribute;
      };

      baseAttribute.offset = (...args) => {
        if (!args.length) {
          return offset;
        }

        offset = args[0];
        return baseAttribute;
      };

      baseAttribute.divisor = (...args) => {
        if (!args.length) {
          return divisor;
        }

        divisor = args[0];
        return baseAttribute;
      };

      return baseAttribute;
    });

    var defaultArrayViewFactory = (() => {
      let type = types.FLOAT;
      let cachedArray = new Float32Array(0);

      const factory = requiredLength => {
        const ArrayType = getArrayViewConstructor(type);

        if (cachedArray.length > requiredLength) {
          cachedArray = new ArrayType(cachedArray.buffer, 0, requiredLength);
        } else if (cachedArray.length !== requiredLength) {
          cachedArray = new ArrayType(requiredLength);
        }

        return cachedArray;
      };

      factory.type = (...args) => {
        if (!args.length) {
          return type;
        }

        if (type !== args[0]) {
          type = args[0];
          const ArrayType = getArrayViewConstructor(type);
          cachedArray = new ArrayType(0);
        }

        return factory;
      };

      return factory;
    });

    var attributeProjector = (() => {
      let dirty = true;
      let size = 1; // per vertex

      let type = types.FLOAT;
      let arrayViewFactory = defaultArrayViewFactory();

      let value = (d, i) => d;

      let data = null;

      const projector = () => {
        const length = data.length;
        const projectedData = arrayViewFactory.type(type)(length * size);

        if (size > 1) {
          for (let i = 0; i < length; i++) {
            const componentValues = value(data[i], i);

            if (componentValues.length !== size) {
              throw new Error(`Expected components array of size ${size}, recieved array with length ${componentValues.length}.`);
            }

            for (let component = 0; component < size; component++) {
              projectedData[i * size + component] = componentValues[component];
            }
          }
        } else {
          for (let i = 0; i < length; i++) {
            const componentValue = value(data[i], i);

            if (Array.isArray(componentValue)) {
              throw new Error(`Expected a single component value, recieved array with length ${componentValue.length}.`);
            }

            projectedData[i] = componentValue;
          }
        }

        dirty = false;
        return projectedData;
      };

      projector.dirty = () => dirty;

      projector.size = (...args) => {
        if (!args.length) {
          return size;
        }

        size = args[0];
        dirty = true;
        return projector;
      };

      projector.type = (...args) => {
        if (!args.length) {
          return type;
        }

        type = args[0];
        dirty = true;
        return projector;
      };

      projector.arrayViewFactory = (...args) => {
        if (!args.length) {
          return arrayViewFactory;
        }

        arrayViewFactory = args[0];
        dirty = true;
        return projector;
      };

      projector.value = (...args) => {
        if (!args.length) {
          return value;
        }

        value = args[0];
        dirty = true;
        return projector;
      };

      projector.data = (...args) => {
        if (!args.length) {
          return data;
        }

        data = args[0];
        dirty = true;
        return projector;
      };

      return projector;
    });

    var vertexAttribute = (() => {
      const base = baseAttributeBuilder();
      const projector = attributeProjector();

      const vertexAttribute = programBuilder => {
        base.size(vertexAttribute.size()).type(vertexAttribute.type());
        base(programBuilder);

        if (!projector.dirty()) {
          return;
        }

        const projectedData = projector();
        const gl = programBuilder.context();
        gl.bindBuffer(gl.ARRAY_BUFFER, base.buffer());
        gl.bufferData(gl.ARRAY_BUFFER, projectedData, gl.DYNAMIC_DRAW);
      };

      rebind(vertexAttribute, base, 'normalized', 'location');
      rebind(vertexAttribute, projector, 'data', 'value', 'size', 'type');
      return vertexAttribute;
    });

    var elementIndices = (initialData => {
      let buffer = null;
      let data = initialData;
      let dirty = true;

      const base = programBuilder => {
        const gl = programBuilder.context();

        if (buffer == null || !gl.isBuffer(buffer)) {
          buffer = gl.createBuffer();
        }

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);

        if (!dirty) {
          return;
        }

        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data), gl.STATIC_DRAW);
        dirty = false;
      };

      base.data = (...args) => {
        if (!args.length) {
          return data;
        }

        dirty = true;
        data = args[0];
        return base;
      };

      return base;
    });

    var rebindCurry = ((target, targetName, source, sourceName, ...curriedArgs) => {
      target[targetName] = (...args) => {
        const result = source[sourceName](...curriedArgs, ...args);

        if (result === source) {
          return target;
        }

        return result;
      };
    });

    var webglSeriesArea = (() => {
      const program = programBuilder().mode(drawModes.TRIANGLES);
      let xScale = baseScale();
      let yScale = baseScale();

      let decorate = () => {};

      const cornerAttribute = vertexAttribute().size(3).type(types.UNSIGNED_BYTE).data([[0, 0, 0], [0, 1, 0], [1, 1, 1], [0, 0, 1], [1, 0, 0], [1, 1, 0]]);
      program.buffers().elementIndices(elementIndices([0, 1, 2, 3, 4, 5])).attribute('aCorner', cornerAttribute);

      const draw = numElements => {
        const shaderBuilder = areaShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        decorate(program);
        program(numElements - 1);
      };

      draw.decorate = (...args) => {
        if (!args.length) {
          return decorate;
        }

        decorate = args[0];
        return draw;
      };

      draw.xScale = (...args) => {
        if (!args.length) {
          return xScale;
        }

        xScale = args[0];
        return draw;
      };

      draw.yScale = (...args) => {
        if (!args.length) {
          return yScale;
        }

        yScale = args[0];
        return draw;
      };

      rebind(draw, program, 'context');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'crossPreviousValueAttribute', program.buffers(), 'attribute', 'aCrossPrevValue');
      rebindCurry(draw, 'mainValueAttribute', program.buffers(), 'attribute', 'aMainValue');
      rebindCurry(draw, 'mainPreviousValueAttribute', program.buffers(), 'attribute', 'aMainPrevValue');
      rebindCurry(draw, 'baseValueAttribute', program.buffers(), 'attribute', 'aBaseValue');
      rebindCurry(draw, 'basePreviousValueAttribute', program.buffers(), 'attribute', 'aBasePrevValue');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      rebindCurry(draw, 'definedNextAttribute', program.buffers(), 'attribute', 'aDefinedNext');
      return draw;
    });

    var circlePointShader = (() => {
      const vertexShader = shaderBuilder(vertexShaderBase);
      const fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(circle.header).appendBody(circle.body);
      fragmentShader.appendHeader(circle$1.header).appendBody(circle$1.body);
      return {
        vertex: () => vertexShader,
        fragment: () => fragmentShader
      };
    });

    var webglSeriesPoint = (() => {
      const program = programBuilder().mode(drawModes.POINTS); // hack to allow a consistent instanced render path

      const ignoredAttribute = vertexAttribute().data([0]);
      program.buffers().attribute('aIgnored', ignoredAttribute).elementIndices(elementIndices([0]));
      let xScale = baseScale();
      let yScale = baseScale();
      let type = circlePointShader();

      let decorate = () => {};

      const draw = numElements => {
        program.vertexShader(type.vertex().appendHeader('attribute float aIgnored;').appendBody('gl_Position += aIgnored;')).fragmentShader(type.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        decorate(program);
        program(numElements);
      };

      draw.type = (...args) => {
        if (!args.length) {
          return type;
        }

        type = args[0];
        return draw;
      };

      draw.decorate = (...args) => {
        if (!args.length) {
          return decorate;
        }

        decorate = args[0];
        return draw;
      };

      draw.xScale = (...args) => {
        if (!args.length) {
          return xScale;
        }

        xScale = args[0];
        return draw;
      };

      draw.yScale = (...args) => {
        if (!args.length) {
          return yScale;
        }

        yScale = args[0];
        return draw;
      };

      rebind(draw, program, 'context');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'mainValueAttribute', program.buffers(), 'attribute', 'aMainValue');
      rebindCurry(draw, 'sizeAttribute', program.buffers(), 'attribute', 'aSize');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      return draw;
    });

    var lineShader = (() => {
      const vertexShader = shaderBuilder(vertexShaderBase);
      const fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(preScaleLine.header).appendBody(preScaleLine.body);
      fragmentShader.appendHeader(line$2.header).appendBody(line$2.body);
      return {
        vertex: () => vertexShader,
        fragment: () => fragmentShader
      };
    });

    var lineWidthShader = (() => {
      let width = 1;

      const lineWidth = program => {
        program.buffers().uniform('uStrokeWidth', uniform(width));
      };

      lineWidth.lineWidth = (...args) => {
        if (!args.length) {
          return width;
        }

        width = args[0];
        return lineWidth;
      };

      return lineWidth;
    });

    var webglSeriesLine = (() => {
      const program = programBuilder().mode(drawModes.TRIANGLES);
      let xScale = baseScale();
      let yScale = baseScale();

      let decorate = () => {};

      const lineWidth = lineWidthShader();
      const cornerAttribute = vertexAttribute().size(3).type(types.BYTE).data([[-1, 0, 0], [1, 1, 0], [1, -1, 1], [-1, 0, 1], [1, 1, 1]]);
      program.buffers().elementIndices(elementIndices([0, 1, 2, 1, 2, 3, 0, 2, 3, 2, 3, 4])).attribute('aCorner', cornerAttribute);

      const draw = numElements => {
        const shaderBuilder = lineShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        xScale(program, 'next', 0);
        yScale(program, 'next', 1);
        xScale(program, 'prev', 0);
        yScale(program, 'prev', 1);
        xScale(program, 'prevPrev', 0);
        yScale(program, 'prevPrev', 1);
        program.vertexShader().appendBody(postScaleLine.body);
        lineWidth(program);
        decorate(program);
        program(numElements - 1);
      };

      draw.decorate = (...args) => {
        if (!args.length) {
          return decorate;
        }

        decorate = args[0];
        return draw;
      };

      draw.xScale = (...args) => {
        if (!args.length) {
          return xScale;
        }

        xScale = args[0];
        return draw;
      };

      draw.yScale = (...args) => {
        if (!args.length) {
          return yScale;
        }

        yScale = args[0];
        return draw;
      };

      rebind(draw, program, 'context');
      rebind(draw, lineWidth, 'lineWidth');
      rebindCurry(draw, 'crossPreviousValueAttribute', program.buffers(), 'attribute', 'aCrossPrevValue');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'crossNextValueAttribute', program.buffers(), 'attribute', 'aCrossNextValue');
      rebindCurry(draw, 'crossPreviousPreviousValueAttribute', program.buffers(), 'attribute', 'aCrossPrevPrevValue');
      rebindCurry(draw, 'mainPreviousValueAttribute', program.buffers(), 'attribute', 'aMainPrevValue');
      rebindCurry(draw, 'mainValueAttribute', program.buffers(), 'attribute', 'aMainValue');
      rebindCurry(draw, 'mainNextValueAttribute', program.buffers(), 'attribute', 'aMainNextValue');
      rebindCurry(draw, 'mainPreviousPreviousValueAttribute', program.buffers(), 'attribute', 'aMainPrevPrevValue');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      rebindCurry(draw, 'definedNextAttribute', program.buffers(), 'attribute', 'aDefinedNext');
      return draw;
    });

    var ohlcShader = (() => {
      const vertexShader = shaderBuilder(vertexShaderBase);
      const fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(ohlc.header).appendBody(ohlc.body);
      fragmentShader.appendHeader(ohlc$1.header).appendBody(ohlc$1.body);
      return {
        vertex: () => vertexShader,
        fragment: () => fragmentShader
      };
    });

    var webglSeriesOhlc = (() => {
      const program = programBuilder().mode(drawModes.TRIANGLES);
      let xScale = baseScale();
      let yScale = baseScale();
      const lineWidth = lineWidthShader();

      let decorate = () => {};
      /*
       * x-y coordinate to locate the "corners" of the element.
       * X: -1: LEFT, 0: MIDDLE, 1: RIGHT
       * Y: -2: HIGH, -1: OPEN, 1: CLOSE, 2: LOW
       * Z - Follows convention for X/Y (appropriate direction will be selected by the shader): -1: LEFT/TOP, 1: RIGHT/BOTTOM
       */


      const cornerAttribute = vertexAttribute().size(3).type(types.BYTE).data([// Main stem
      [0, -2, -1], [0, -2, 1], [0, 2, 1], [0, 2, -1], // Open bar
      [-1, -1, -1], [-1, -1, 1], [0, -1, 1], [0, -1, -1], // Close bar
      [1, 1, 1], [0, 1, 1], [0, 1, -1], [1, 1, -1]]);
      program.buffers().elementIndices(elementIndices([// Main stem
      0, 1, 2, 0, 3, 2, // Open bar
      4, 5, 6, 4, 7, 6, // Close bar
      8, 9, 10, 10, 11, 8])).attribute('aCorner', cornerAttribute);

      const draw = numElements => {
        const shaderBuilder = ohlcShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        lineWidth(program);
        program.vertexShader().appendBody(`
          gl_Position.x += xModifier / uScreen.x;
          gl_Position.y += yModifier / uScreen.y;
        `);
        decorate(program);
        program(numElements);
      };

      draw.decorate = (...args) => {
        if (!args.length) {
          return decorate;
        }

        decorate = args[0];
        return draw;
      };

      draw.xScale = (...args) => {
        if (!args.length) {
          return xScale;
        }

        xScale = args[0];
        return draw;
      };

      draw.yScale = (...args) => {
        if (!args.length) {
          return yScale;
        }

        yScale = args[0];
        return draw;
      };

      rebind(draw, program, 'context');
      rebind(draw, lineWidth, 'lineWidth');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'openValueAttribute', program.buffers(), 'attribute', 'aOpenValue');
      rebindCurry(draw, 'highValueAttribute', program.buffers(), 'attribute', 'aHighValue');
      rebindCurry(draw, 'lowValueAttribute', program.buffers(), 'attribute', 'aLowValue');
      rebindCurry(draw, 'closeValueAttribute', program.buffers(), 'attribute', 'aCloseValue');
      rebindCurry(draw, 'bandwidthAttribute', program.buffers(), 'attribute', 'aBandwidth');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      return draw;
    });

    var barShader = (() => {
      const vertexShader = shaderBuilder(vertexShaderBase);
      const fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(bar.header).appendBody(bar.body);
      fragmentShader.appendHeader(bar$1.header).appendBody(bar$1.body);
      return {
        vertex: () => vertexShader,
        fragment: () => fragmentShader
      };
    });

    //     .-------------.------------.
    // (x-w/2, y1)    (x, y1)   (x+w/2, y1)
    //     |     \                    |
    //     |        \                 |
    //     |           \              |
    //     |              \           |
    //     |                 \        |
    //     |                    \     |
    //     |                       \  |
    //     αL            α            αR
    //     .-------------.------------.
    // (x-w/2, y0)     (x, y0)   (x+w/2, y0)
    // Drawing order
    // Triangle βL, αL, αR. (bottom)
    // β -> βL.
    // α -> αL.
    // α -> αR.
    // Triangle βL, αR, βR. (top)
    // β -> βL.
    // α -> αR.
    // β -> βR.

    var webglSeriesBar = (() => {
      const program = programBuilder().mode(drawModes.TRIANGLES);
      let xScale = baseScale();
      let yScale = baseScale();

      let decorate = () => {};

      const cornerAttribute = vertexAttribute().size(2).type(types.BYTE).data([[-1, -1], [1, 1], [-1, 1], [1, -1]]);
      program.buffers().elementIndices(elementIndices([0, 1, 2, 0, 1, 3])).attribute('aCorner', cornerAttribute);

      const draw = numElements => {
        const shaderBuilder = barShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        program.vertexShader().appendBody(`
            gl_Position.x += xModifier / uScreen.x * 2.0;
        `);
        decorate(program);
        program(numElements);
      };

      draw.decorate = (...args) => {
        if (!args.length) {
          return decorate;
        }

        decorate = args[0];
        return draw;
      };

      draw.xScale = (...args) => {
        if (!args.length) {
          return xScale;
        }

        xScale = args[0];
        return draw;
      };

      draw.yScale = (...args) => {
        if (!args.length) {
          return yScale;
        }

        yScale = args[0];
        return draw;
      };

      rebind(draw, program, 'context');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'mainValueAttribute', program.buffers(), 'attribute', 'aMainValue');
      rebindCurry(draw, 'baseValueAttribute', program.buffers(), 'attribute', 'aBaseValue');
      rebindCurry(draw, 'bandwidthAttribute', program.buffers(), 'attribute', 'aBandwidth');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      return draw;
    });

    var errorBarShader = (() => {
      const vertexShader = shaderBuilder(vertexShaderBase);
      const fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(errorBar.header).appendBody(errorBar.body);
      fragmentShader.appendHeader(errorBar$1.header).appendBody(errorBar$1.body);
      return {
        vertex: () => vertexShader,
        fragment: () => fragmentShader
      };
    });

    var webglSeriesErrorBar = (() => {
      const program = programBuilder().mode(drawModes.TRIANGLES);
      let xScale = baseScale();
      let yScale = baseScale();

      let decorate = () => {};

      const lineWidth = lineWidthShader();
      /*
       * x-y coordinate to locate the "corners" of the element (ie errorbar). The `z` coordinate locates the corner relative to the line (this takes line width into account).
       * X: -1: LEFT, 0: MIDDLE, 1: RIGHT
       * Y: -1: HIGH, 1: LOW
       * Z: Follows X or Y convention, depending on the orientation of the line that the vertex is part of.
       */

      const cornerAttribute = vertexAttribute().size(3).type(types.BYTE).data([// Main stem
      [0, 1, 1], [0, 1, -1], [0, -1, -1], [0, -1, 1], // Top cap
      [1, -1, 1], [1, -1, -1], [-1, -1, -1], [-1, -1, 1], // Bottom cap
      [-1, 1, -1], [-1, 1, 1], [1, 1, 1], [1, 1, -1]]);
      program.buffers().elementIndices(elementIndices([// Main stem
      0, 1, 2, 0, 3, 2, // Top cap
      4, 5, 6, 4, 7, 6, // Bottom cap
      8, 9, 10, 8, 11, 10])).attribute('aCorner', cornerAttribute);

      const draw = numElements => {
        const shaderBuilder = errorBarShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        lineWidth(program);
        program.vertexShader().appendBody(`
                gl_Position.x += xModifier / uScreen.x * 2.0;
                gl_Position.y += yModifier / uScreen.y * 2.0;
            `);
        decorate(program);
        program(numElements);
      };

      draw.decorate = (...args) => {
        if (!args.length) {
          return decorate;
        }

        decorate = args[0];
        return draw;
      };

      draw.xScale = (...args) => {
        if (!args.length) {
          return xScale;
        }

        xScale = args[0];
        return draw;
      };

      draw.yScale = (...args) => {
        if (!args.length) {
          return yScale;
        }

        yScale = args[0];
        return draw;
      };

      rebind(draw, program, 'context');
      rebind(draw, lineWidth, 'lineWidth');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'highValueAttribute', program.buffers(), 'attribute', 'aHighValue');
      rebindCurry(draw, 'lowValueAttribute', program.buffers(), 'attribute', 'aLowValue');
      rebindCurry(draw, 'bandwidthAttribute', program.buffers(), 'attribute', 'aBandwidth');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      return draw;
    });

    var candlestickShader = (() => {
      const vertexShader = shaderBuilder(vertexShaderBase);
      const fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(candlestick.header).appendBody(candlestick.body);
      fragmentShader.appendHeader(candlestick$1.header).appendBody(candlestick$1.body);
      return {
        vertex: () => vertexShader,
        fragment: () => fragmentShader
      };
    });

    var webglSeriesCandlestick = (() => {
      const program = programBuilder().mode(drawModes.TRIANGLES);
      let xScale = baseScale();
      let yScale = baseScale();
      const lineWidth = lineWidthShader();

      let decorate = () => {};
      /*
       * x-y coordinate to locate the "corners" of the element.
       * X: -1: LEFT, 0: MIDDLE, 1: RIGHT
       * Y: -2: HIGH, -1: OPEN, 1: CLOSE, 2: LOW
       * Z: -1: LEFT, 1: RIGHT (only valid for HIGH/LOW corners)
       */


      const cornerAttribute = vertexAttribute().size(3).type(types.BYTE).data([// Vertical line
      [0, 2, 1], [0, 2, -1], [0, -2, -1], [0, -2, 1], // Central box
      [1, -1, 0], [-1, -1, 0], [-1, 1, 0], [1, 1, 0]]);
      program.buffers().elementIndices(elementIndices([// Vertical line
      0, 1, 2, 0, 3, 2, // Central box
      4, 5, 6, 4, 7, 6])).attribute('aCorner', cornerAttribute);

      const draw = numElements => {
        const shaderBuilder = candlestickShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        lineWidth(program);
        program.vertexShader().appendBody(`
          gl_Position.x += xModifier / uScreen.x;
          gl_Position.y += yModifier / uScreen.y;
        `);
        decorate(program);
        program(numElements);
      };

      draw.decorate = (...args) => {
        if (!args.length) {
          return decorate;
        }

        decorate = args[0];
        return draw;
      };

      draw.xScale = (...args) => {
        if (!args.length) {
          return xScale;
        }

        xScale = args[0];
        return draw;
      };

      draw.yScale = (...args) => {
        if (!args.length) {
          return yScale;
        }

        yScale = args[0];
        return draw;
      };

      rebind(draw, program, 'context');
      rebind(draw, lineWidth, 'lineWidth');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'openValueAttribute', program.buffers(), 'attribute', 'aOpenValue');
      rebindCurry(draw, 'highValueAttribute', program.buffers(), 'attribute', 'aHighValue');
      rebindCurry(draw, 'lowValueAttribute', program.buffers(), 'attribute', 'aLowValue');
      rebindCurry(draw, 'closeValueAttribute', program.buffers(), 'attribute', 'aCloseValue');
      rebindCurry(draw, 'bandwidthAttribute', program.buffers(), 'attribute', 'aBandwidth');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      return draw;
    });

    var boxPlotShader = (() => {
      const vertexShader = shaderBuilder(vertexShaderBase);
      const fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(boxPlot.header).appendBody(boxPlot.body);
      fragmentShader.appendHeader(boxPlot$1.header).appendBody(boxPlot$1.body);
      return {
        vertex: () => vertexShader,
        fragment: () => fragmentShader
      };
    });

    //            .------.------.
    //                   |
    //                   |
    //                   |
    //    βL2            β           βR2
    //     .-------------.------------.
    //     |                          |
    //     |                          |
    //     |                          |
    //     γL2            γ           γR2
    //     .-------------.------------.
    //     |                          |
    //     |                          |
    //     |                          |
    //    δL2            δ           δR2
    //     .-------------.------------.
    //                   |
    //                   |
    //                   |
    //           εL1     ε     εR1
    //            .------.------.
    // Line drawing order
    // αL1 -> αR1
    // α -> β
    // βL2 -> βR2
    // γL2 -> γR2
    // δL2 -> δR2
    // βL2 -> δL2
    // βR2 -> δR2
    // δ -> ε
    // εL1 -> εR1

    var webglSeriesBoxPlot = (() => {
      const program = programBuilder().mode(drawModes.TRIANGLES);
      let xScale = baseScale();
      let yScale = baseScale();

      let decorate = () => {};

      const lineWidth = lineWidthShader();
      /*
       * x-y coordinate to locate the "corners" of the element (ie errorbar). The `z` coordinate locates the corner relative to the line (this takes line width into account).
       * X: -1: LEFT, 0: MIDDLE, 1: RIGHT
       * Y: -2: HIGH, -1: UPPER QUARTILE, 0: MEDIAN, 1: LOWER QUARTILE, 2: LOW
       * Z: Follows X or Y convention, depending on the orientation of the line that the vertex is part of.
       * W: Indicator to determine line orientation (needed because some corners are part of two lines). - 0: VERTICAL, 1: HORIZONTAL
       */

      const cornerAttribute = vertexAttribute().size(4).type(types.BYTE).data([// Top cap line
      [-1, -2, -1, 1], [1, -2, -1, 1], [1, -2, 1, 1], [-1, -2, 1, 1], // Top whisker line
      [0, -2, -1, 0], [0, -2, 1, 0], [0, -1, 1, 0], [0, -1, -1, 0], // Upper quartile line
      [-1, -1, -1, 1], [1, -1, -1, 1], [1, -1, 1, 1], [-1, -1, 1, 1], // Median line
      [-1, 0, -1, 1], [1, 0, -1, 1], [1, 0, 1, 1], [-1, 0, 1, 1], // Lower quartile line
      [-1, 1, -1, 1], [1, 1, -1, 1], [1, 1, 1, 1], [-1, 1, 1, 1], // Left box vertical line
      [-1, -1, -1, 0], [-1, -1, 1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], // Right box vertical line
      [1, -1, -1, 0], [1, -1, 1, 0], [1, 1, 1, 0], [1, 1, -1, 0], // Bottom whisker line
      [0, 2, -1, 0], [0, 2, 1, 0], [0, 1, 1, 0], [0, 1, -1, 0], // Bottom cap line
      [-1, 2, -1, 1], [1, 2, -1, 1], [1, 2, 1, 1], [-1, 2, 1, 1]]);
      program.buffers().elementIndices(elementIndices([// Top cap line
      0, 1, 2, 0, 2, 3, // Top whisker line
      4, 5, 6, 4, 6, 7, // Upper quartile line
      8, 9, 10, 8, 10, 11, // Median line
      12, 13, 14, 12, 14, 15, // Lower quartile line
      16, 17, 18, 16, 18, 19, // Left box vertical line
      20, 21, 22, 20, 22, 23, // Right box vertical line
      24, 25, 26, 24, 26, 27, // Bottom whisker line
      28, 29, 30, 28, 30, 31, // Bottom cap line
      32, 33, 34, 32, 34, 35])).attribute('aCorner', cornerAttribute);

      const draw = numElements => {
        const shaderBuilder = boxPlotShader();
        program.vertexShader(shaderBuilder.vertex()).fragmentShader(shaderBuilder.fragment());
        xScale(program, 'gl_Position', 0);
        yScale(program, 'gl_Position', 1);
        lineWidth(program);
        program.vertexShader().appendBody(`
            gl_Position.x += xModifier / uScreen.x * 2.0;
            gl_Position.y += yModifier / uScreen.y * 2.0;
        `);
        decorate(program);
        program(numElements);
      };

      draw.decorate = (...args) => {
        if (!args.length) {
          return decorate;
        }

        decorate = args[0];
        return draw;
      };

      draw.xScale = (...args) => {
        if (!args.length) {
          return xScale;
        }

        xScale = args[0];
        return draw;
      };

      draw.yScale = (...args) => {
        if (!args.length) {
          return yScale;
        }

        yScale = args[0];
        return draw;
      };

      rebind(draw, program, 'context');
      rebind(draw, lineWidth, 'lineWidth');
      rebindCurry(draw, 'crossValueAttribute', program.buffers(), 'attribute', 'aCrossValue');
      rebindCurry(draw, 'highValueAttribute', program.buffers(), 'attribute', 'aHighValue');
      rebindCurry(draw, 'upperQuartileValueAttribute', program.buffers(), 'attribute', 'aUpperQuartileValue');
      rebindCurry(draw, 'medianValueAttribute', program.buffers(), 'attribute', 'aMedianValue');
      rebindCurry(draw, 'lowerQuartileValueAttribute', program.buffers(), 'attribute', 'aLowerQuartileValue');
      rebindCurry(draw, 'lowValueAttribute', program.buffers(), 'attribute', 'aLowValue');
      rebindCurry(draw, 'bandwidthAttribute', program.buffers(), 'attribute', 'aBandwidth');
      rebindCurry(draw, 'capAttribute', program.buffers(), 'attribute', 'aCapWidth');
      rebindCurry(draw, 'definedAttribute', program.buffers(), 'attribute', 'aDefined');
      return draw;
    });

    var webglAdjacentElementAttribute = ((minOffset = 0, maxOffset = 0) => {
      if (minOffset > 0 || maxOffset < 0) {
        throw new Error(`Offset values (${minOffset} & ${maxOffset}) must straddle 0 `);
      }

      const base = baseAttributeBuilder().divisor(1);
      const projector = attributeProjector();

      const adjacentAttribute = programBuilder => {
        const elementSize = adjacentAttribute.size() * length(adjacentAttribute.type());
        const bufferOffset = Math.abs(minOffset) * elementSize;
        base.offset(bufferOffset).size(adjacentAttribute.size()).type(adjacentAttribute.type());
        base(programBuilder);

        if (!projector.dirty()) {
          return;
        }

        const projectedData = projector();
        const bufferPadding = maxOffset * elementSize;
        const bufferLength = bufferOffset + projectedData.length * length(adjacentAttribute.type()) + bufferPadding;
        const gl = programBuilder.context();
        gl.bindBuffer(gl.ARRAY_BUFFER, base.buffer());
        gl.bufferData(gl.ARRAY_BUFFER, bufferLength, gl.DYNAMIC_DRAW);
        gl.bufferSubData(gl.ARRAY_BUFFER, bufferOffset, projectedData);
      };

      adjacentAttribute.offset = offset => {
        if (minOffset > offset || offset > maxOffset) {
          throw new Error(`Requested offset ${offset} exceeds bounds (${minOffset} & ${maxOffset}) `);
        }

        const offsetAttribute = programBuilder => {
          base.offset((offset - minOffset) * adjacentAttribute.size() * length(adjacentAttribute.type()));
          base(programBuilder);
        };

        rebind(offsetAttribute, base, 'location');
        return offsetAttribute;
      };

      rebind(adjacentAttribute, base, 'normalized', 'location');
      rebind(adjacentAttribute, projector, 'data', 'value', 'size', 'type');
      return adjacentAttribute;
    });

    var webglElementAttribute = (() => {
      const base = baseAttributeBuilder().divisor(1);
      const projector = attributeProjector();

      const elementAttribute = programBuilder => {
        base.size(elementAttribute.size()).type(elementAttribute.type());
        base(programBuilder);

        if (!projector.dirty()) {
          return;
        }

        const projectedData = projector();
        const gl = programBuilder.context();
        gl.bindBuffer(gl.ARRAY_BUFFER, base.buffer());
        gl.bufferData(gl.ARRAY_BUFFER, projectedData, gl.DYNAMIC_DRAW);
      };

      rebind(elementAttribute, base, 'normalized', 'location');
      rebind(elementAttribute, projector, 'data', 'value', 'size', 'type');
      return elementAttribute;
    });

    var linear = (() => {
      const base = baseScale();

      const prefix = component => `linear${component}`;

      const scale = (programBuilder, identifier, component) => {
        programBuilder.vertexShader().appendHeaderIfNotExists(`uniform vec4 ${prefix(component)}Offset;`).appendHeaderIfNotExists(`uniform vec4 ${prefix(component)}Scale;`).appendBody(`${identifier} = ${identifier} + ${prefix(component)}Offset;`).appendBody(`${identifier} = ${identifier} * ${prefix(component)}Scale;`);
        const domainSize = base.domain()[1] - base.domain()[0];
        const rangeSize = base.range()[1] - base.range()[0];
        const translate = base.range()[0] * (domainSize / rangeSize) - base.domain()[0];
        const scaleFactor = rangeSize / domainSize;
        const offset = [0, 0, 0, 0];
        const scale = [1, 1, 1, 1];
        offset[component] = translate;
        scale[component] = scaleFactor;
        programBuilder.buffers().uniform(`${prefix(component)}Offset`, uniform(offset)).uniform(`${prefix(component)}Scale`, uniform(scale));
      };

      rebindAll(scale, base);
      return scale;
    });

    var log = (() => {
      const glBase = baseScale();
      let base = 10;

      function log(v, base) {
        return Math.log10(v) / Math.log10(base);
      }

      const prefix = component => `log${component}`;

      const scale = (programBuilder, identifier, component) => {
        const logPart = `${prefix(component)}Offset + (${prefix(component)}Scale * clamp(log(${identifier}) / log(${prefix(component)}Base), -inf, inf))`;
        programBuilder.vertexShader().appendHeaderIfNotExists(`uniform vec4 ${prefix(component)}Offset;`).appendHeaderIfNotExists(`uniform vec4 ${prefix(component)}Scale;`).appendHeaderIfNotExists(`uniform vec4 ${prefix(component)}Include;`).appendHeaderIfNotExists(`uniform float ${prefix(component)}Base;`).appendBody(`${identifier} = (${prefix(component)}Include * (${logPart})) + ((1.0 - ${prefix(component)}Include) * ${identifier});`);
        const domainSize = log(glBase.domain()[1], base) - log(glBase.domain()[0], base);
        const rangeSize = glBase.range()[1] - glBase.range()[0];
        const scaleFactor = rangeSize / domainSize;
        const translate = glBase.range()[0] - scaleFactor * log(glBase.domain()[0], base);
        const offset = [0, 0, 0, 0];
        const scale = [0, 0, 0, 0];
        const include = [0, 0, 0, 0];
        offset[component] = translate;
        scale[component] = scaleFactor;
        include[component] = 1;
        programBuilder.buffers().uniform(`${prefix(component)}Offset`, uniform(offset)).uniform(`${prefix(component)}Scale`, uniform(scale)).uniform(`${prefix(component)}Include`, uniform(include)).uniform(`${prefix(component)}Base`, uniform(base));
      };

      scale.base = (...args) => {
        if (!args.length) {
          return base;
        }

        base = args[0];
        return scale;
      };

      rebindAll(scale, glBase);
      return scale;
    });

    var pow = (() => {
      const base = baseScale();
      let exponent = 1;

      function pow(b, e) {
        return Math.sign(b) * Math.pow(Math.abs(b), e);
      }

      const prefix = component => `pow${component}`;

      const scale = (programBuilder, identifier, component) => {
        const powPart = `${prefix(component)}Offset + (${prefix(component)}Scale * sign(${identifier}) * pow(abs(${identifier}), vec4(${prefix(component)}Exp)))`;
        programBuilder.vertexShader().appendHeaderIfNotExists(`uniform vec4 ${prefix(component)}Offset;`).appendHeaderIfNotExists(`uniform vec4 ${prefix(component)}Scale;`).appendHeaderIfNotExists(`uniform vec4 ${prefix(component)}Include;`).appendHeaderIfNotExists(`uniform float ${prefix(component)}Exp;`).appendBody(`${identifier} = (${prefix(component)}Include * (${powPart})) + ((1.0 - ${prefix(component)}Include) * ${identifier});`);
        const domainSize = pow(base.domain()[1], exponent) - pow(base.domain()[0], exponent);
        const rangeSize = base.range()[1] - base.range()[0];
        const scaleFactor = rangeSize / domainSize;
        const translate = base.range()[0] - scaleFactor * pow(base.domain()[0], exponent);
        const offset = [0, 0, 0, 0];
        const scale = [0, 0, 0, 0];
        const include = [0, 0, 0, 0];
        offset[component] = translate;
        scale[component] = scaleFactor;
        include[component] = 1;
        programBuilder.buffers().uniform(`${prefix(component)}Offset`, uniform(offset)).uniform(`${prefix(component)}Scale`, uniform(scale)).uniform(`${prefix(component)}Include`, uniform(include)).uniform(`${prefix(component)}Exp`, uniform(exponent));
      };

      scale.exponent = (...args) => {
        if (!args.length) {
          return exponent;
        }

        exponent = args[0];
        return scale;
      };

      rebindAll(scale, base);
      return scale;
    });

    var webglScaleMapper = (scale => {
      let outScale = d3Scale__default.scaleIdentity();
      let glScale = null;
      const scaleCopyString = scale.copy.toString(); // compare the stringified 'copy' function of the scale to
      // determine the scale type.

      if (scaleCopyString === d3Scale__default.scaleLinear().copy.toString()) {
        glScale = linear().domain(scale.domain());
      } else if (scaleCopyString === d3Scale__default.scaleLog().copy.toString()) {
        glScale = log().domain(scale.domain()).base(scale.base());
      } else if (scaleCopyString === d3Scale__default.scalePow().copy.toString()) {
        glScale = pow().domain(scale.domain()).exponent(scale.exponent());
      } else if (scaleCopyString === d3Scale__default.scaleTime().copy.toString()) {
        glScale = linear().domain(scale.domain());
      } else {
        glScale = linear().domain(scale.range());
        outScale = scale;
      }

      return {
        scale: outScale,
        glScale: glScale
      };
    });

    var squarePointShader = (() => {
      const vertexShader = shaderBuilder(vertexShaderBase);
      const fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(square.header).appendBody(square.body);
      fragmentShader.appendHeader(square$1.header).appendBody(square$1.body);
      return {
        vertex: () => vertexShader,
        fragment: () => fragmentShader
      };
    });

    var trianglePointShader = (() => {
      const vertexShader = shaderBuilder(vertexShaderBase);
      const fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(triangle.header).appendBody(triangle.body);
      fragmentShader.appendHeader(triangle$1.header).appendBody(triangle$1.body);
      return {
        vertex: () => vertexShader,
        fragment: () => fragmentShader
      };
    });

    var crossPointShader = (() => {
      const vertexShader = shaderBuilder(vertexShaderBase);
      const fragmentShader = shaderBuilder(fragmentShaderBase);
      vertexShader.appendHeader(cross.header).appendBody(cross.body);
      fragmentShader.appendHeader(cross$1.header).appendBody(cross$1.body);
      return {
        vertex: () => vertexShader,
        fragment: () => fragmentShader
      };
    });

    var webglSymbolMapper = (symbol => {
      switch (symbol) {
        case d3Shape__default.symbolCircle:
          return circlePointShader();

        case d3Shape__default.symbolSquare:
          return squarePointShader();

        case d3Shape__default.symbolTriangle:
          return trianglePointShader();

        case d3Shape__default.symbolCross:
          return crossPointShader();

        default:
          throw new Error(`Unrecognised symbol: ${symbol}`);
      }
    });

    var line$3 = (function () {
      var base = xyBase();
      var crossPreviousValueAttribute = webglAdjacentElementAttribute(-1, 2);
      var crossValueAttribute = crossPreviousValueAttribute.offset(1);
      var crossNextValueAttribute = crossPreviousValueAttribute.offset(2);
      var crossPreviousPreviousValueAttribute = crossPreviousValueAttribute.offset(-1);
      var mainPreviousValueAttribute = webglAdjacentElementAttribute(-1, 2);
      var mainValueAttribute = mainPreviousValueAttribute.offset(1);
      var mainNextValueAttribute = mainPreviousValueAttribute.offset(2);
      var mainPreviousPreviousValueAttribute = mainPreviousValueAttribute.offset(-1);
      var definedAttribute = webglAdjacentElementAttribute(0, 1).type(types.UNSIGNED_BYTE);
      var definedNextAttribute = definedAttribute.offset(1);
      var draw = webglSeriesLine().crossPreviousValueAttribute(crossPreviousValueAttribute).crossValueAttribute(crossValueAttribute).crossNextValueAttribute(crossNextValueAttribute).crossPreviousPreviousValueAttribute(crossPreviousPreviousValueAttribute).mainPreviousValueAttribute(mainPreviousValueAttribute).mainValueAttribute(mainValueAttribute).mainNextValueAttribute(mainNextValueAttribute).mainPreviousPreviousValueAttribute(mainPreviousPreviousValueAttribute).definedAttribute(definedAttribute).definedNextAttribute(definedNextAttribute);

      var equals = function equals(previousData, data) {
        return false;
      };

      var previousData = [];

      var line = function line(data) {
        var xScale = webglScaleMapper(base.xScale());
        var yScale = webglScaleMapper(base.yScale());

        if (!isIdentityScale(xScale.scale) || !isIdentityScale(yScale.scale) || !equals(previousData, data)) {
          previousData = data;

          if (base.orient() === 'vertical') {
            crossPreviousValueAttribute.value(function (d, i) {
              return xScale.scale(base.crossValue()(d, i));
            }).data(data);
            mainPreviousValueAttribute.value(function (d, i) {
              return yScale.scale(base.mainValue()(d, i));
            }).data(data);
          } else {
            crossPreviousValueAttribute.value(function (d, i) {
              return xScale.scale(base.mainValue()(d, i));
            }).data(data);
            mainPreviousValueAttribute.value(function (d, i) {
              return yScale.scale(base.crossValue()(d, i));
            }).data(data);
          }

          definedAttribute.value(function (d, i) {
            return base.defined()(d, i);
          }).data(data);
        }

        draw.xScale(xScale.glScale).yScale(yScale.glScale).decorate(function (program) {
          return base.decorate()(program, data, 0);
        });
        draw(data.length);
      };

      line.equals = function () {
        if (!arguments.length) {
          return equals;
        }

        equals = arguments.length <= 0 ? undefined : arguments[0];
        return line;
      };

      rebindAll(line, base, exclude('baseValue', 'bandwidth', 'align'));
      rebind(line, draw, 'context', 'lineWidth');
      return line;
    });

    var point = (function () {
      var symbol = d3Shape.symbol();
      var base = xyBase();
      var join = dataJoin('g', 'point');

      var containerTransform = function containerTransform(origin) {
        return 'translate(' + origin[0] + ', ' + origin[1] + ')';
      };

      var point = function point(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        selection.each(function (data, index, group) {
          var filteredData = data.filter(base.defined());
          var g = join(d3Selection.select(group[index]), filteredData);
          g.enter().attr('transform', function (d, i) {
            return containerTransform(base.values(d, i).origin);
          }).attr('fill', colors.gray).attr('stroke', colors.black).append('path');
          g.attr('transform', function (d, i) {
            return containerTransform(base.values(d, i).origin);
          }).select('path').attr('d', symbol);
          base.decorate()(g, data, index);
        });
      };

      rebindAll(point, base, exclude('baseValue', 'bandwidth', 'align'));
      rebind(point, join, 'key');
      rebind(point, symbol, 'type', 'size');
      return point;
    });

    var point$1 = (function () {
      var symbol = d3Shape.symbol();
      var base = xyBase();

      var point = function point(data) {
        var filteredData = data.filter(base.defined());
        var context = symbol.context();
        filteredData.forEach(function (d, i) {
          context.save();
          var values = base.values(d, i);
          context.translate(values.origin[0], values.origin[1]);
          context.beginPath();
          context.strokeStyle = colors.black;
          context.fillStyle = colors.gray;
          base.decorate()(context, d, i);
          symbol(d, i);
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      rebindAll(point, base, exclude('baseValue', 'bandwidth', 'align'));
      rebind(point, symbol, 'size', 'type', 'context');
      return point;
    });

    var point$2 = (function () {
      var base = xyBase();
      var size = functor(64);
      var type = d3Shape__default.symbolCircle;
      var crossValueAttribute = webglElementAttribute();
      var mainValueAttribute = webglElementAttribute();
      var sizeAttribute = webglElementAttribute().type(types.UNSIGNED_SHORT);
      var definedAttribute = webglElementAttribute().type(types.UNSIGNED_BYTE);
      var draw = webglSeriesPoint().crossValueAttribute(crossValueAttribute).mainValueAttribute(mainValueAttribute).sizeAttribute(sizeAttribute).definedAttribute(definedAttribute);

      var equals = function equals(previousData, data) {
        return false;
      };

      var previousData = [];

      var point = function point(data) {
        var xScale = webglScaleMapper(base.xScale());
        var yScale = webglScaleMapper(base.yScale());

        if (!isIdentityScale(xScale.scale) || !isIdentityScale(yScale.scale) || !equals(previousData, data)) {
          previousData = data;

          if (base.orient() === 'vertical') {
            crossValueAttribute.value(function (d, i) {
              return xScale.scale(base.crossValue()(d, i));
            }).data(data);
            mainValueAttribute.value(function (d, i) {
              return yScale.scale(base.mainValue()(d, i));
            }).data(data);
          } else {
            crossValueAttribute.value(function (d, i) {
              return xScale.scale(base.mainValue()(d, i));
            }).data(data);
            mainValueAttribute.value(function (d, i) {
              return yScale.scale(base.crossValue()(d, i));
            }).data(data);
          }

          sizeAttribute.value(function (d, i) {
            return size(d, i);
          }).data(data);
          definedAttribute.value(function (d, i) {
            return base.defined()(d, i);
          }).data(data);
        }

        draw.xScale(xScale.glScale).yScale(yScale.glScale).type(webglSymbolMapper(type)).decorate(function (program) {
          return base.decorate()(program, data, 0);
        });
        draw(data.length);
      };

      point.size = function () {
        if (!arguments.length) {
          return size;
        }

        size = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return point;
      };

      point.type = function () {
        if (!arguments.length) {
          return type;
        }

        type = arguments.length <= 0 ? undefined : arguments[0];
        return point;
      };

      point.equals = function () {
        if (!arguments.length) {
          return equals;
        }

        equals = arguments.length <= 0 ? undefined : arguments[0];
        return point;
      };

      rebindAll(point, base, exclude('baseValue', 'bandwidth', 'align'));
      rebind(point, draw, 'context');
      return point;
    });

    var functor$1 = (v => typeof v === 'function' ? v : () => v);

    // OHLC has a fixed width, whilst the x, open, high, low and close positions are
    // obtained from each point via the supplied accessor functions.

    var shapeOhlc = (() => {
      let context = null;

      let x = d => d.date;

      let open = d => d.open;

      let high = d => d.high;

      let low = d => d.low;

      let close = d => d.close;

      let orient = 'vertical';
      let width = functor$1(3);

      const ohlc = function (data) {
        const drawingContext = context || d3Path.path();
        data.forEach(function (d, i) {
          const xValue = x(d, i);
          const yOpen = open(d, i);
          const yHigh = high(d, i);
          const yLow = low(d, i);
          const yClose = close(d, i);
          const halfWidth = width(d, i) / 2;

          if (orient === 'vertical') {
            drawingContext.moveTo(xValue, yLow);
            drawingContext.lineTo(xValue, yHigh);
            drawingContext.moveTo(xValue, yOpen);
            drawingContext.lineTo(xValue - halfWidth, yOpen);
            drawingContext.moveTo(xValue, yClose);
            drawingContext.lineTo(xValue + halfWidth, yClose);
          } else {
            drawingContext.moveTo(yLow, xValue);
            drawingContext.lineTo(yHigh, xValue);
            drawingContext.moveTo(yOpen, xValue);
            drawingContext.lineTo(yOpen, xValue + halfWidth);
            drawingContext.moveTo(yClose, xValue);
            drawingContext.lineTo(yClose, xValue - halfWidth);
          }
        });
        return context ? null : drawingContext.toString();
      };

      ohlc.context = (...args) => {
        if (!args.length) {
          return context;
        }

        context = args[0];
        return ohlc;
      };

      ohlc.x = (...args) => {
        if (!args.length) {
          return x;
        }

        x = functor$1(args[0]);
        return ohlc;
      };

      ohlc.open = (...args) => {
        if (!args.length) {
          return open;
        }

        open = functor$1(args[0]);
        return ohlc;
      };

      ohlc.high = (...args) => {
        if (!args.length) {
          return high;
        }

        high = functor$1(args[0]);
        return ohlc;
      };

      ohlc.low = (...args) => {
        if (!args.length) {
          return low;
        }

        low = functor$1(args[0]);
        return ohlc;
      };

      ohlc.close = (...args) => {
        if (!args.length) {
          return close;
        }

        close = functor$1(args[0]);
        return ohlc;
      };

      ohlc.width = (...args) => {
        if (!args.length) {
          return width;
        }

        width = functor$1(args[0]);
        return ohlc;
      };

      ohlc.orient = (...args) => {
        if (!args.length) {
          return orient;
        }

        orient = args[0];
        return ohlc;
      };

      return ohlc;
    });

    // bar has a fixed width, whilst the x, y and height are obtained from each data
    // point via the supplied accessor functions.

    var shapeBar = (() => {
      let context = null;

      let x = d => d.x;

      let y = d => d.y;

      let horizontalAlign = 'center';
      let verticalAlign = 'center';

      let height = d => d.height;

      let width = functor$1(3);

      const bar = function (data, index) {
        const drawingContext = context || d3Path.path();
        data.forEach(function (d, i) {
          const xValue = x.call(this, d, index || i);
          const yValue = y.call(this, d, index || i);
          const barHeight = height.call(this, d, index || i);
          const barWidth = width.call(this, d, index || i);
          let horizontalOffset;

          switch (horizontalAlign) {
            case 'left':
              horizontalOffset = barWidth;
              break;

            case 'right':
              horizontalOffset = 0;
              break;

            case 'center':
              horizontalOffset = barWidth / 2;
              break;

            default:
              throw new Error('Invalid horizontal alignment ' + horizontalAlign);
          }

          let verticalOffset;

          switch (verticalAlign) {
            case 'bottom':
              verticalOffset = -barHeight;
              break;

            case 'top':
              verticalOffset = 0;
              break;

            case 'center':
              verticalOffset = barHeight / 2;
              break;

            default:
              throw new Error('Invalid vertical alignment ' + verticalAlign);
          }

          drawingContext.rect(xValue - horizontalOffset, yValue - verticalOffset, barWidth, barHeight);
        }, this);
        return context ? null : drawingContext.toString();
      };

      bar.context = (...args) => {
        if (!args.length) {
          return context;
        }

        context = args[0];
        return bar;
      };

      bar.x = (...args) => {
        if (!args.length) {
          return x;
        }

        x = functor$1(args[0]);
        return bar;
      };

      bar.y = (...args) => {
        if (!args.length) {
          return y;
        }

        y = functor$1(args[0]);
        return bar;
      };

      bar.width = (...args) => {
        if (!args.length) {
          return width;
        }

        width = functor$1(args[0]);
        return bar;
      };

      bar.horizontalAlign = (...args) => {
        if (!args.length) {
          return horizontalAlign;
        }

        horizontalAlign = args[0];
        return bar;
      };

      bar.height = (...args) => {
        if (!args.length) {
          return height;
        }

        height = functor$1(args[0]);
        return bar;
      };

      bar.verticalAlign = (...args) => {
        if (!args.length) {
          return verticalAlign;
        }

        verticalAlign = args[0];
        return bar;
      };

      return bar;
    });

    // candlestick has a fixed width, whilst the x, open, high, low and close positions are
    // obtained from each point via the supplied accessor functions.

    var shapeCandlestick = (() => {
      let context = null;

      let x = d => d.date;

      let open = d => d.open;

      let high = d => d.high;

      let low = d => d.low;

      let close = d => d.close;

      let width = functor$1(3);

      const candlestick = function (data) {
        const drawingContext = context || d3Path.path();
        data.forEach(function (d, i) {
          const xValue = x(d, i);
          const yOpen = open(d, i);
          const yHigh = high(d, i);
          const yLow = low(d, i);
          const yClose = close(d, i);
          const barWidth = width(d, i);
          const halfBarWidth = barWidth / 2; // Body

          drawingContext.rect(xValue - halfBarWidth, yOpen, barWidth, yClose - yOpen); // High wick
          // // Move to the max price of close or open; draw the high wick
          // N.B. Math.min() is used as we're dealing with pixel values,
          // the lower the pixel value, the higher the price!

          drawingContext.moveTo(xValue, Math.min(yClose, yOpen));
          drawingContext.lineTo(xValue, yHigh); // Low wick
          // // Move to the min price of close or open; draw the low wick
          // N.B. Math.max() is used as we're dealing with pixel values,
          // the higher the pixel value, the lower the price!

          drawingContext.moveTo(xValue, Math.max(yClose, yOpen));
          drawingContext.lineTo(xValue, yLow);
        });
        return context ? null : drawingContext.toString();
      };

      candlestick.context = (...args) => {
        if (!args.length) {
          return context;
        }

        context = args[0];
        return candlestick;
      };

      candlestick.x = (...args) => {
        if (!args.length) {
          return x;
        }

        x = functor$1(args[0]);
        return candlestick;
      };

      candlestick.open = (...args) => {
        if (!args.length) {
          return open;
        }

        open = functor$1(args[0]);
        return candlestick;
      };

      candlestick.high = (...args) => {
        if (!args.length) {
          return high;
        }

        high = functor$1(args[0]);
        return candlestick;
      };

      candlestick.low = (...args) => {
        if (!args.length) {
          return low;
        }

        low = functor$1(args[0]);
        return candlestick;
      };

      candlestick.close = (...args) => {
        if (!args.length) {
          return close;
        }

        close = functor$1(args[0]);
        return candlestick;
      };

      candlestick.width = (...args) => {
        if (!args.length) {
          return width;
        }

        width = functor$1(args[0]);
        return candlestick;
      };

      return candlestick;
    });

    var shapeBoxPlot = (() => {
      let context = null;

      let value = d => d.value;

      let median = d => d.median;

      let upperQuartile = d => d.upperQuartile;

      let lowerQuartile = d => d.lowerQuartile;

      let high = d => d.high;

      let low = d => d.low;

      let orient = 'vertical';
      let width = functor$1(5);
      let cap = functor$1(0.5);

      const boxPlot = function (data) {
        const drawingContext = context || d3Path.path();
        data.forEach(function (d, i) {
          // naming convention is for vertical orientation
          const _value = value(d, i);

          const _width = width(d, i);

          const halfWidth = _width / 2;

          const capWidth = _width * cap(d, i);

          const halfCapWidth = capWidth / 2;

          const _high = high(d, i);

          const _upperQuartile = upperQuartile(d, i);

          const _median = median(d, i);

          const _lowerQuartile = lowerQuartile(d, i);

          const _low = low(d, i);

          const upperQuartileToLowerQuartile = _lowerQuartile - _upperQuartile;

          if (orient === 'vertical') {
            // Upper whisker
            drawingContext.moveTo(_value - halfCapWidth, _high);
            drawingContext.lineTo(_value + halfCapWidth, _high);
            drawingContext.moveTo(_value, _high);
            drawingContext.lineTo(_value, _upperQuartile); // Box

            drawingContext.rect(_value - halfWidth, _upperQuartile, _width, upperQuartileToLowerQuartile);
            drawingContext.moveTo(_value - halfWidth, _median); // Median line

            drawingContext.lineTo(_value + halfWidth, _median); // Lower whisker

            drawingContext.moveTo(_value, _lowerQuartile);
            drawingContext.lineTo(_value, _low);
            drawingContext.moveTo(_value - halfCapWidth, _low);
            drawingContext.lineTo(_value + halfCapWidth, _low);
          } else {
            // Lower whisker
            drawingContext.moveTo(_low, _value - halfCapWidth);
            drawingContext.lineTo(_low, _value + halfCapWidth);
            drawingContext.moveTo(_low, _value);
            drawingContext.lineTo(_lowerQuartile, _value); // Box

            drawingContext.rect(_lowerQuartile, _value - halfWidth, -upperQuartileToLowerQuartile, _width);
            drawingContext.moveTo(_median, _value - halfWidth);
            drawingContext.lineTo(_median, _value + halfWidth); // Upper whisker

            drawingContext.moveTo(_upperQuartile, _value);
            drawingContext.lineTo(_high, _value);
            drawingContext.moveTo(_high, _value - halfCapWidth);
            drawingContext.lineTo(_high, _value + halfCapWidth);
          }
        });
        return context ? null : drawingContext.toString();
      };

      boxPlot.context = (...args) => {
        if (!args.length) {
          return context;
        }

        context = args[0];
        return boxPlot;
      };

      boxPlot.value = (...args) => {
        if (!args.length) {
          return value;
        }

        value = functor$1(args[0]);
        return boxPlot;
      };

      boxPlot.median = (...args) => {
        if (!args.length) {
          return median;
        }

        median = functor$1(args[0]);
        return boxPlot;
      };

      boxPlot.upperQuartile = (...args) => {
        if (!args.length) {
          return upperQuartile;
        }

        upperQuartile = functor$1(args[0]);
        return boxPlot;
      };

      boxPlot.lowerQuartile = (...args) => {
        if (!args.length) {
          return lowerQuartile;
        }

        lowerQuartile = functor$1(args[0]);
        return boxPlot;
      };

      boxPlot.high = (...args) => {
        if (!args.length) {
          return high;
        }

        high = functor$1(args[0]);
        return boxPlot;
      };

      boxPlot.low = (...args) => {
        if (!args.length) {
          return low;
        }

        low = functor$1(args[0]);
        return boxPlot;
      };

      boxPlot.width = (...args) => {
        if (!args.length) {
          return width;
        }

        width = functor$1(args[0]);
        return boxPlot;
      };

      boxPlot.orient = (...args) => {
        if (!args.length) {
          return orient;
        }

        orient = args[0];
        return boxPlot;
      };

      boxPlot.cap = (...args) => {
        if (!args.length) {
          return cap;
        }

        cap = functor$1(args[0]);
        return boxPlot;
      };

      return boxPlot;
    });

    var shapeErrorBar = (() => {
      let context = null;

      let value = d => d.x;

      let high = d => d.high;

      let low = d => d.low;

      let orient = 'vertical';
      let width = functor$1(5);

      const errorBar = function (data) {
        const drawingContext = context || d3Path.path();
        data.forEach(function (d, i) {
          // naming convention is for vertical orientation
          const _value = value(d, i);

          const _width = width(d, i);

          const halfWidth = _width / 2;

          const _high = high(d, i);

          const _low = low(d, i);

          if (orient === 'vertical') {
            drawingContext.moveTo(_value - halfWidth, _high);
            drawingContext.lineTo(_value + halfWidth, _high);
            drawingContext.moveTo(_value, _high);
            drawingContext.lineTo(_value, _low);
            drawingContext.moveTo(_value - halfWidth, _low);
            drawingContext.lineTo(_value + halfWidth, _low);
          } else {
            drawingContext.moveTo(_low, _value - halfWidth);
            drawingContext.lineTo(_low, _value + halfWidth);
            drawingContext.moveTo(_low, _value);
            drawingContext.lineTo(_high, _value);
            drawingContext.moveTo(_high, _value - halfWidth);
            drawingContext.lineTo(_high, _value + halfWidth);
          }
        });
        return context ? null : drawingContext.toString();
      };

      errorBar.context = (...args) => {
        if (!args.length) {
          return context;
        }

        context = args[0];
        return errorBar;
      };

      errorBar.value = (...args) => {
        if (!args.length) {
          return value;
        }

        value = functor$1(args[0]);
        return errorBar;
      };

      errorBar.high = (...args) => {
        if (!args.length) {
          return high;
        }

        high = functor$1(args[0]);
        return errorBar;
      };

      errorBar.low = (...args) => {
        if (!args.length) {
          return low;
        }

        low = functor$1(args[0]);
        return errorBar;
      };

      errorBar.width = (...args) => {
        if (!args.length) {
          return width;
        }

        width = functor$1(args[0]);
        return errorBar;
      };

      errorBar.orient = (...args) => {
        if (!args.length) {
          return orient;
        }

        orient = args[0];
        return errorBar;
      };

      return errorBar;
    });

    var bar$2 = (function () {
      var pathGenerator = shapeBar().x(0).y(0);
      var base = xyBase();
      var join = dataJoin('g', 'bar');

      var valueAxisDimension = function valueAxisDimension(generator) {
        return base.orient() === 'vertical' ? generator.height : generator.width;
      };

      var crossAxisDimension = function crossAxisDimension(generator) {
        return base.orient() === 'vertical' ? generator.width : generator.height;
      };

      var translation = function translation(origin) {
        return 'translate(' + origin[0] + ', ' + origin[1] + ')';
      };

      var bar = function bar(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        selection.each(function (data, index, group) {
          var orient = base.orient();

          if (orient !== 'vertical' && orient !== 'horizontal') {
            throw new Error('The bar series does not support an orientation of ' + orient);
          }

          var filteredData = data.filter(base.defined());
          var projectedData = filteredData.map(base.values);
          pathGenerator.width(0).height(0);

          if (base.orient() === 'vertical') {
            pathGenerator.verticalAlign('top');
            pathGenerator.horizontalAlign('center');
          } else {
            pathGenerator.horizontalAlign('right');
            pathGenerator.verticalAlign('center');
          }

          var g = join(d3Selection.select(group[index]), filteredData); // within the enter selection the pathGenerator creates a zero
          // height bar on the baseline. As a result, when used with a transition the bar grows
          // from y0 to y1 (y)

          g.enter().attr('transform', function (_, i) {
            return translation(projectedData[i].baseOrigin);
          }).attr('class', 'bar ' + base.orient()).attr('fill', colors.darkGray).append('path').attr('d', function (d, i) {
            crossAxisDimension(pathGenerator)(projectedData[i].width);
            return pathGenerator([d]);
          }); // the container translation sets the origin to the 'tip'
          // of each bar as per the decorate pattern

          g.attr('transform', function (_, i) {
            return translation(projectedData[i].origin);
          }).select('path').attr('d', function (d, i) {
            crossAxisDimension(pathGenerator)(projectedData[i].width);
            valueAxisDimension(pathGenerator)(-projectedData[i].height);
            return pathGenerator([d]);
          });
          base.decorate()(g, filteredData, index);
        });
      };

      rebindAll(bar, base);
      rebind(bar, join, 'key');
      return bar;
    });

    var bar$3 = (function () {
      var base = xyBase();
      var pathGenerator = shapeBar().x(0).y(0);

      var valueAxisDimension = function valueAxisDimension(generator) {
        return base.orient() === 'vertical' ? generator.height : generator.width;
      };

      var crossAxisDimension = function crossAxisDimension(generator) {
        return base.orient() === 'vertical' ? generator.width : generator.height;
      };

      var bar = function bar(data) {
        var context = pathGenerator.context();
        var filteredData = data.filter(base.defined());
        var projectedData = filteredData.map(base.values);

        if (base.orient() === 'vertical') {
          pathGenerator.verticalAlign('top');
          pathGenerator.horizontalAlign('center');
        } else {
          pathGenerator.horizontalAlign('right');
          pathGenerator.verticalAlign('center');
        }

        projectedData.forEach(function (datum, i) {
          context.save();
          context.beginPath();
          context.translate(datum.origin[0], datum.origin[1]);
          context.fillStyle = colors.darkGray;
          context.strokeStyle = 'transparent';
          base.decorate()(context, datum.d, i);
          valueAxisDimension(pathGenerator)(-datum.height);
          crossAxisDimension(pathGenerator)(datum.width);
          pathGenerator([datum]);
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      rebindAll(bar, base);
      rebind(bar, pathGenerator, 'context');
      return bar;
    });

    var bar$4 = (function () {
      var base = xyBase();
      var crossValueAttribute = webglElementAttribute();
      var mainValueAttribute = webglElementAttribute();
      var baseValueAttribute = webglElementAttribute();
      var bandwidthAttribute = webglElementAttribute().type(types.UNSIGNED_SHORT);
      var definedAttribute = webglElementAttribute().type(types.UNSIGNED_BYTE);
      var draw = webglSeriesBar().crossValueAttribute(crossValueAttribute).mainValueAttribute(mainValueAttribute).baseValueAttribute(baseValueAttribute).bandwidthAttribute(bandwidthAttribute).definedAttribute(definedAttribute);

      var equals = function equals(previousData, data) {
        return false;
      };

      var previousData = [];

      var bar = function bar(data) {
        if (base.orient() !== 'vertical') {
          throw new Error("Unsupported orientation ".concat(base.orient()));
        }

        var xScale = webglScaleMapper(base.xScale());
        var yScale = webglScaleMapper(base.yScale());

        if (!isIdentityScale(xScale.scale) || !isIdentityScale(yScale.scale) || !equals(previousData, data)) {
          previousData = data;
          crossValueAttribute.value(function (d, i) {
            return xScale.scale(base.crossValue()(d, i));
          }).data(data);
          mainValueAttribute.value(function (d, i) {
            return yScale.scale(base.mainValue()(d, i));
          }).data(data);
          baseValueAttribute.value(function (d, i) {
            return yScale.scale(base.baseValue()(d, i));
          }).data(data);
          bandwidthAttribute.value(function (d, i) {
            return base.bandwidth()(d, i);
          }).data(data);
          definedAttribute.value(function (d, i) {
            return base.defined()(d, i);
          }).data(data);
        }

        draw.xScale(xScale.glScale).yScale(yScale.glScale).decorate(function (program) {
          return base.decorate()(program, data, 0);
        });
        draw(data.length);
      };

      bar.equals = function () {
        if (!arguments.length) {
          return equals;
        }

        equals = arguments.length <= 0 ? undefined : arguments[0];
        return bar;
      };

      rebindAll(bar, base, exclude('align'));
      rebind(bar, draw, 'context');
      return bar;
    });

    var errorBarBase = (function () {
      var highValue = function highValue(d) {
        return d.high;
      };

      var lowValue = function lowValue(d) {
        return d.low;
      };

      var crossValue = function crossValue(d) {
        return d.cross;
      };

      var orient = 'vertical';
      var align = 'center';

      var bandwidth = function bandwidth() {
        return 5;
      };

      var base = createBase({
        decorate: function decorate() {},
        defined: function defined$1(d, i) {
          return defined(lowValue, highValue, crossValue)(d, i);
        },
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity()
      });

      base.values = function (d, i) {
        var width = bandwidth(d, i);
        var offset = alignOffset(align, width);
        var xScale = base.xScale();
        var yScale = base.yScale();

        if (orient === 'vertical') {
          var y = yScale(highValue(d, i));
          return {
            origin: [xScale(crossValue(d, i)) + offset, y],
            high: 0,
            low: yScale(lowValue(d, i)) - y,
            width: width
          };
        } else {
          var x = xScale(lowValue(d, i));
          return {
            origin: [x, yScale(crossValue(d, i)) + offset],
            high: xScale(highValue(d, i)) - x,
            low: 0,
            width: width
          };
        }
      };

      base.xValues = function () {
        return orient === 'vertical' ? [crossValue] : [highValue, lowValue];
      };

      base.yValues = function () {
        return orient !== 'vertical' ? [crossValue] : [highValue, lowValue];
      };

      base.orient = function () {
        if (!arguments.length) {
          return orient;
        }

        orient = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.lowValue = function () {
        if (!arguments.length) {
          return lowValue;
        }

        lowValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.highValue = function () {
        if (!arguments.length) {
          return highValue;
        }

        highValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.crossValue = function () {
        if (!arguments.length) {
          return crossValue;
        }

        crossValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.bandwidth = function () {
        if (!arguments.length) {
          return bandwidth;
        }

        bandwidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.align = function () {
        if (!arguments.length) {
          return align;
        }

        align = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      return base;
    });

    var errorBar$2 = (function () {
      var base = errorBarBase();
      var join = dataJoin('g', 'error-bar');
      var pathGenerator = shapeErrorBar().value(0);

      var propagateTransition = function propagateTransition(maybeTransition) {
        return function (selection) {
          return maybeTransition.selection ? selection.transition(maybeTransition) : selection;
        };
      };

      var containerTranslation = function containerTranslation(values) {
        return 'translate(' + values.origin[0] + ', ' + values.origin[1] + ')';
      };

      var errorBar = function errorBar(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        var transitionPropagator = propagateTransition(selection);
        selection.each(function (data, index, group) {
          var filteredData = data.filter(base.defined());
          var projectedData = filteredData.map(base.values);
          var g = join(d3Selection.select(group[index]), filteredData);
          g.enter().attr('stroke', colors.black).attr('fill', colors.gray).attr('transform', function (d, i) {
            return containerTranslation(base.values(d, i)) + ' scale(1e-6, 1)';
          }).append('path');
          pathGenerator.orient(base.orient());
          g.each(function (d, i, g) {
            var values = projectedData[i];
            pathGenerator.high(values.high).low(values.low).width(values.width);
            transitionPropagator(d3Selection.select(g[i])).attr('transform', containerTranslation(values) + ' scale(1)').select('path').attr('d', pathGenerator([d]));
          });
          base.decorate()(g, data, index);
        });
      };

      rebindAll(errorBar, base);
      rebind(errorBar, join, 'key');
      return errorBar;
    });

    var errorBar$3 = (function () {
      var base = errorBarBase();
      var pathGenerator = shapeErrorBar().value(0);

      var errorBar = function errorBar(data) {
        var filteredData = data.filter(base.defined());
        var context = pathGenerator.context();
        pathGenerator.orient(base.orient());
        filteredData.forEach(function (d, i) {
          context.save();
          var values = base.values(d, i);
          context.translate(values.origin[0], values.origin[1]);
          context.beginPath();
          context.strokeStyle = colors.black;
          context.fillStyle = colors.gray;
          base.decorate()(context, d, i);
          pathGenerator.high(values.high).width(values.width).low(values.low)([d]);
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      rebindAll(errorBar, base);
      rebind(errorBar, pathGenerator, 'context');
      return errorBar;
    });

    var errorBar$4 = (function () {
      var base = errorBarBase();
      var crossValueAttribute = webglElementAttribute();
      var highValueAttribute = webglElementAttribute();
      var lowValueAttribute = webglElementAttribute();
      var bandwidthAttribute = webglElementAttribute().type(types.UNSIGNED_SHORT);
      var definedAttribute = webglElementAttribute().type(types.UNSIGNED_BYTE);
      var draw = webglSeriesErrorBar().crossValueAttribute(crossValueAttribute).highValueAttribute(highValueAttribute).lowValueAttribute(lowValueAttribute).bandwidthAttribute(bandwidthAttribute).definedAttribute(definedAttribute);

      var equals = function equals(previousData, data) {
        return false;
      };

      var previousData = [];

      var errorBar = function errorBar(data) {
        if (base.orient() !== 'vertical') {
          throw new Error("Unsupported orientation ".concat(base.orient()));
        }

        var xScale = webglScaleMapper(base.xScale());
        var yScale = webglScaleMapper(base.yScale());

        if (!isIdentityScale(xScale.scale) || !isIdentityScale(yScale.scale) || !equals(previousData, data)) {
          previousData = data;
          crossValueAttribute.value(function (d, i) {
            return xScale.scale(base.crossValue()(d, i));
          }).data(data);
          highValueAttribute.value(function (d, i) {
            return yScale.scale(base.highValue()(d, i));
          }).data(data);
          lowValueAttribute.value(function (d, i) {
            return yScale.scale(base.lowValue()(d, i));
          }).data(data);
          bandwidthAttribute.value(function (d, i) {
            return base.bandwidth()(d, i);
          }).data(data);
          definedAttribute.value(function (d, i) {
            return base.defined()(d, i);
          }).data(data);
        }

        draw.xScale(xScale.glScale).yScale(yScale.glScale).decorate(function (program) {
          return base.decorate()(program, data, 0);
        });
        draw(data.length);
      };

      errorBar.equals = function () {
        if (!arguments.length) {
          return equals;
        }

        equals = arguments.length <= 0 ? undefined : arguments[0];
        return errorBar;
      };

      rebindAll(errorBar, base, exclude('align'));
      rebind(errorBar, draw, 'context', 'lineWidth');
      return errorBar;
    });

    var area$2 = (function () {
      var base = xyBase();
      var areaData = d3Shape.area();
      var join = dataJoin('path', 'area');

      var area = function area(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        areaData.defined(base.defined());
        selection.each(function (data, index, group) {
          var projectedData = data.map(base.values);
          areaData.x(function (_, i) {
            return projectedData[i].transposedX;
          }).y(function (_, i) {
            return projectedData[i].transposedY;
          });
          var valueComponent = base.orient() === 'vertical' ? 'y' : 'x';
          areaData[valueComponent + '0'](function (_, i) {
            return projectedData[i].y0;
          });
          areaData[valueComponent + '1'](function (_, i) {
            return projectedData[i].y;
          });
          var path = join(d3Selection.select(group[index]), [data]);
          path.enter().attr('fill', colors.gray);
          path.attr('d', areaData);
          base.decorate()(path, data, index);
        });
      };

      rebindAll(area, base, exclude('bandwidth', 'align'));
      rebind(area, join, 'key');
      rebind(area, areaData, 'curve');
      return area;
    });

    var area$3 = (function () {
      var base = xyBase();
      var areaData = d3Shape.area();

      var area = function area(data) {
        var context = areaData.context();
        areaData.defined(base.defined());
        var projectedData = data.map(base.values);
        areaData.x(function (_, i) {
          return projectedData[i].transposedX;
        }).y(function (_, i) {
          return projectedData[i].transposedY;
        });
        var valueComponent = base.orient() === 'vertical' ? 'y' : 'x';
        areaData[valueComponent + '0'](function (_, i) {
          return projectedData[i].y0;
        });
        areaData[valueComponent + '1'](function (_, i) {
          return projectedData[i].y;
        });
        context.beginPath();
        context.fillStyle = colors.gray;
        context.strokeStyle = 'transparent';
        base.decorate()(context, data);
        areaData(data);
        context.fill();
        context.stroke();
        context.closePath();
      };

      rebindAll(area, base, exclude('bandwidth', 'align'));
      rebind(area, areaData, 'curve', 'context');
      return area;
    });

    var area$4 = (function () {
      var base = xyBase();
      var crossPreviousValueAttribute = webglAdjacentElementAttribute(0, 1);
      var crossValueAttribute = crossPreviousValueAttribute.offset(1);
      var mainPreviousValueAttribute = webglAdjacentElementAttribute(0, 1);
      var mainValueAttribute = mainPreviousValueAttribute.offset(1);
      var basePreviousValueAttribute = webglAdjacentElementAttribute(0, 1);
      var baseValueAttribute = basePreviousValueAttribute.offset(1);
      var definedAttribute = webglAdjacentElementAttribute(0, 1).type(types.UNSIGNED_BYTE);
      var definedNextAttribute = definedAttribute.offset(1);
      var draw = webglSeriesArea().crossValueAttribute(crossValueAttribute).crossPreviousValueAttribute(crossPreviousValueAttribute).mainValueAttribute(mainValueAttribute).mainPreviousValueAttribute(mainPreviousValueAttribute).baseValueAttribute(baseValueAttribute).basePreviousValueAttribute(basePreviousValueAttribute).definedAttribute(definedAttribute).definedNextAttribute(definedNextAttribute);

      var equals = function equals(previousData, data) {
        return false;
      };

      var previousData = [];

      var area = function area(data) {
        if (base.orient() !== 'vertical') {
          throw new Error("Unsupported orientation ".concat(base.orient()));
        }

        var xScale = webglScaleMapper(base.xScale());
        var yScale = webglScaleMapper(base.yScale());

        if (!isIdentityScale(xScale.scale) || !isIdentityScale(yScale.scale) || !equals(previousData, data)) {
          previousData = data;
          crossPreviousValueAttribute.value(function (d, i) {
            return xScale.scale(base.crossValue()(d, i));
          }).data(data);
          mainPreviousValueAttribute.value(function (d, i) {
            return yScale.scale(base.mainValue()(d, i));
          }).data(data);
          basePreviousValueAttribute.value(function (d, i) {
            return yScale.scale(base.baseValue()(d, i));
          }).data(data);
          definedAttribute.value(function (d, i) {
            return base.defined()(d, i);
          }).data(data);
        }

        draw.xScale(xScale.glScale).yScale(yScale.glScale).decorate(function (program) {
          return base.decorate()(program, data, 0);
        });
        draw(data.length);
      };

      area.equals = function () {
        if (!arguments.length) {
          return equals;
        }

        equals = arguments.length <= 0 ? undefined : arguments[0];
        return area;
      };

      rebindAll(area, base, exclude('bandwidth', 'align'));
      rebind(area, draw, 'context');
      return area;
    });

    var ohlcBase = (function () {
      var base;

      var crossValue = function crossValue(d) {
        return d.date;
      };

      var openValue = function openValue(d) {
        return d.open;
      };

      var highValue = function highValue(d) {
        return d.high;
      };

      var lowValue = function lowValue(d) {
        return d.low;
      };

      var closeValue = function closeValue(d) {
        return d.close;
      };

      var bandwidth = function bandwidth() {
        return 5;
      };

      var align = 'center';

      var crossValueScaled = function crossValueScaled(d, i) {
        return base.xScale()(crossValue(d, i));
      };

      base = createBase({
        decorate: function decorate() {},
        defined: function defined$1(d, i) {
          return defined(crossValue, openValue, lowValue, highValue, closeValue)(d, i);
        },
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity()
      });

      base.values = function (d, i) {
        var closeRaw = closeValue(d, i);
        var openRaw = openValue(d, i);
        var width = bandwidth(d, i);
        var offset = alignOffset(align, width);
        var direction = '';

        if (closeRaw > openRaw) {
          direction = 'up';
        } else if (closeRaw < openRaw) {
          direction = 'down';
        }

        return {
          cross: crossValueScaled(d, i) + offset,
          open: base.yScale()(openRaw),
          high: base.yScale()(highValue(d, i)),
          low: base.yScale()(lowValue(d, i)),
          close: base.yScale()(closeRaw),
          width: width,
          direction: direction
        };
      };

      base.xValues = function () {
        return [crossValue];
      };

      base.yValues = function () {
        return [openValue, highValue, lowValue, closeValue];
      };

      base.crossValue = function () {
        if (!arguments.length) {
          return crossValue;
        }

        crossValue = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.openValue = function () {
        if (!arguments.length) {
          return openValue;
        }

        openValue = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.highValue = function () {
        if (!arguments.length) {
          return highValue;
        }

        highValue = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.lowValue = function () {
        if (!arguments.length) {
          return lowValue;
        }

        lowValue = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.yValue = base.closeValue = function () {
        if (!arguments.length) {
          return closeValue;
        }

        closeValue = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.bandwidth = function () {
        if (!arguments.length) {
          return bandwidth;
        }

        bandwidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.align = function () {
        if (!arguments.length) {
          return align;
        }

        align = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      return base;
    });

    var ohlcBase$1 = (function (pathGenerator, seriesName) {
      var base = ohlcBase();
      var join = dataJoin('g', seriesName);

      var containerTranslation = function containerTranslation(values) {
        return 'translate(' + values.cross + ', ' + values.high + ')';
      };

      var propagateTransition = function propagateTransition(maybeTransition) {
        return function (selection) {
          return maybeTransition.selection ? selection.transition(maybeTransition) : selection;
        };
      };

      var candlestick = function candlestick(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        var transitionPropagator = propagateTransition(selection);
        selection.each(function (data, index, group) {
          var filteredData = data.filter(base.defined());
          var g = join(d3Selection.select(group[index]), filteredData);
          g.enter().attr('transform', function (d, i) {
            return containerTranslation(base.values(d, i)) + ' scale(1e-6, 1)';
          }).append('path');
          g.each(function (d, i, g) {
            var values = base.values(d, i);
            var color = values.direction === 'up' ? colors.green : colors.red;
            var singleCandlestick = transitionPropagator(d3Selection.select(g[i])).attr('class', seriesName + ' ' + values.direction).attr('stroke', color).attr('fill', color).attr('transform', function () {
              return containerTranslation(values) + ' scale(1)';
            });
            pathGenerator.x(0).width(values.width).open(function () {
              return values.open - values.high;
            }).high(0).low(function () {
              return values.low - values.high;
            }).close(function () {
              return values.close - values.high;
            });
            singleCandlestick.select('path').attr('d', pathGenerator([d]));
          });
          base.decorate()(g, data, index);
        });
      };

      rebind(candlestick, join, 'key');
      rebindAll(candlestick, base);
      return candlestick;
    });

    var candlestick$2 = (function () {
      return ohlcBase$1(shapeCandlestick(), 'candlestick');
    });

    var ohlcBase$2 = (function (pathGenerator) {
      var base = ohlcBase();

      var candlestick = function candlestick(data) {
        var filteredData = data.filter(base.defined());
        var context = pathGenerator.context();
        filteredData.forEach(function (d, i) {
          context.save();
          var values = base.values(d, i);
          context.translate(values.cross, values.high);
          context.beginPath();
          pathGenerator.x(0).open(function () {
            return values.open - values.high;
          }).width(values.width).high(0).low(function () {
            return values.low - values.high;
          }).close(function () {
            return values.close - values.high;
          })([d]);
          var color = values.direction === 'up' ? colors.green : colors.red;
          context.strokeStyle = color;
          context.fillStyle = color;
          base.decorate()(context, d, i);
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      rebind(candlestick, pathGenerator, 'context');
      rebindAll(candlestick, base);
      return candlestick;
    });

    var candlestick$3 = (function () {
      return ohlcBase$2(shapeCandlestick());
    });

    var ohlcBase$3 = (function (pathGenerator) {
      var base = ohlcBase();
      var crossValueAttribute = webglElementAttribute();
      var openValueAttribute = webglElementAttribute();
      var highValueAttribute = webglElementAttribute();
      var lowValueAttribute = webglElementAttribute();
      var closeValueAttribute = webglElementAttribute();
      var bandwidthAttribute = webglElementAttribute().type(types.UNSIGNED_SHORT);
      var definedAttribute = webglElementAttribute().type(types.UNSIGNED_BYTE);
      pathGenerator.crossValueAttribute(crossValueAttribute).openValueAttribute(openValueAttribute).highValueAttribute(highValueAttribute).lowValueAttribute(lowValueAttribute).closeValueAttribute(closeValueAttribute).bandwidthAttribute(bandwidthAttribute).definedAttribute(definedAttribute);

      var equals = function equals(previousData, data) {
        return false;
      };

      var previousData = [];

      var candlestick = function candlestick(data) {
        var xScale = webglScaleMapper(base.xScale());
        var yScale = webglScaleMapper(base.yScale());

        if (!isIdentityScale(xScale.scale) || !isIdentityScale(yScale.scale) || !equals(previousData, data)) {
          previousData = data;
          crossValueAttribute.value(function (d, i) {
            return xScale.scale(base.crossValue()(d, i));
          }).data(data);
          openValueAttribute.value(function (d, i) {
            return yScale.scale(base.openValue()(d, i));
          }).data(data);
          highValueAttribute.value(function (d, i) {
            return yScale.scale(base.highValue()(d, i));
          }).data(data);
          lowValueAttribute.value(function (d, i) {
            return yScale.scale(base.lowValue()(d, i));
          }).data(data);
          closeValueAttribute.value(function (d, i) {
            return yScale.scale(base.closeValue()(d, i));
          }).data(data);
          bandwidthAttribute.value(function (d, i) {
            return base.bandwidth()(d, i);
          }).data(data);
          definedAttribute.value(function (d, i) {
            return base.defined()(d, i);
          }).data(data);
        }

        pathGenerator.xScale(xScale.glScale).yScale(yScale.glScale).decorate(function (program) {
          return base.decorate()(program, data, 0);
        });
        pathGenerator(data.length);
      };

      candlestick.equals = function () {
        if (!arguments.length) {
          return equals;
        }

        equals = arguments.length <= 0 ? undefined : arguments[0];
        return candlestick;
      };

      rebindAll(candlestick, base, exclude('align'));
      rebind(candlestick, pathGenerator, 'context', 'lineWidth');
      return candlestick;
    });

    var candlestick$4 = (function () {
      return ohlcBase$3(webglSeriesCandlestick());
    });

    var boxPlotBase = (function () {
      var upperQuartileValue = function upperQuartileValue(d) {
        return d.upperQuartile;
      };

      var lowerQuartileValue = function lowerQuartileValue(d) {
        return d.lowerQuartile;
      };

      var highValue = function highValue(d) {
        return d.high;
      };

      var lowValue = function lowValue(d) {
        return d.low;
      };

      var crossValue = function crossValue(d) {
        return d.value;
      };

      var medianValue = function medianValue(d) {
        return d.median;
      };

      var orient = 'vertical';
      var align = 'center';

      var bandwidth = function bandwidth() {
        return 5;
      };

      var base = createBase({
        decorate: function decorate() {},
        defined: function defined$1(d, i) {
          return defined(lowValue, highValue, lowerQuartileValue, upperQuartileValue, crossValue, medianValue)(d, i);
        },
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity()
      });

      base.values = function (d, i) {
        var width = bandwidth(d, i);
        var offset = alignOffset(align, width);
        var xScale = base.xScale();
        var yScale = base.yScale();

        if (orient === 'vertical') {
          var y = yScale(highValue(d, i));
          return {
            origin: [xScale(crossValue(d, i)) + offset, y],
            high: 0,
            upperQuartile: yScale(upperQuartileValue(d, i)) - y,
            median: yScale(medianValue(d, i)) - y,
            lowerQuartile: yScale(lowerQuartileValue(d, i)) - y,
            low: yScale(lowValue(d, i)) - y,
            width: width
          };
        } else {
          var x = xScale(lowValue(d, i));
          return {
            origin: [x, yScale(crossValue(d, i)) + offset],
            high: xScale(highValue(d, i)) - x,
            upperQuartile: xScale(upperQuartileValue(d, i)) - x,
            median: xScale(medianValue(d, i)) - x,
            lowerQuartile: xScale(lowerQuartileValue(d, i)) - x,
            low: 0,
            width: width
          };
        }
      };

      base.xValues = function () {
        return orient === 'vertical' ? [crossValue] : [upperQuartileValue, lowerQuartileValue, highValue, lowValue, medianValue];
      };

      base.yValues = function () {
        return orient !== 'vertical' ? [crossValue] : [upperQuartileValue, lowerQuartileValue, highValue, lowValue, medianValue];
      };

      base.orient = function () {
        if (!arguments.length) {
          return orient;
        }

        orient = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      base.lowerQuartileValue = function () {
        if (!arguments.length) {
          return lowerQuartileValue;
        }

        lowerQuartileValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.upperQuartileValue = function () {
        if (!arguments.length) {
          return upperQuartileValue;
        }

        upperQuartileValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.lowValue = function () {
        if (!arguments.length) {
          return lowValue;
        }

        lowValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.highValue = function () {
        if (!arguments.length) {
          return highValue;
        }

        highValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.crossValue = function () {
        if (!arguments.length) {
          return crossValue;
        }

        crossValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.medianValue = function () {
        if (!arguments.length) {
          return medianValue;
        }

        medianValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.bandwidth = function () {
        if (!arguments.length) {
          return bandwidth;
        }

        bandwidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return base;
      };

      base.align = function () {
        if (!arguments.length) {
          return align;
        }

        align = arguments.length <= 0 ? undefined : arguments[0];
        return base;
      };

      return base;
    });

    var boxPlot$2 = (function () {
      var base = boxPlotBase();
      var join = dataJoin('g', 'box-plot');
      var pathGenerator = shapeBoxPlot().value(0);

      var propagateTransition = function propagateTransition(maybeTransition) {
        return function (selection) {
          return maybeTransition.selection ? selection.transition(maybeTransition) : selection;
        };
      };

      var containerTranslation = function containerTranslation(values) {
        return 'translate(' + values.origin[0] + ', ' + values.origin[1] + ')';
      };

      var boxPlot = function boxPlot(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        var transitionPropagator = propagateTransition(selection);
        selection.each(function (data, index, group) {
          var filteredData = data.filter(base.defined());
          var g = join(d3Selection.select(group[index]), filteredData);
          g.enter().attr('stroke', colors.black).attr('fill', colors.gray).attr('transform', function (d, i) {
            return containerTranslation(base.values(d, i)) + ' scale(1e-6, 1)';
          }).append('path');
          pathGenerator.orient(base.orient());
          g.each(function (d, i, g) {
            var values = base.values(d, i);
            pathGenerator.median(values.median).upperQuartile(values.upperQuartile).lowerQuartile(values.lowerQuartile).width(values.width).high(values.high).low(values.low);
            transitionPropagator(d3Selection.select(g[i])).attr('transform', containerTranslation(values)).select('path').attr('d', pathGenerator([d]));
          });
          base.decorate()(g, data, index);
        });
      };

      rebindAll(boxPlot, base);
      rebind(boxPlot, join, 'key');
      rebind(boxPlot, pathGenerator, 'cap');
      return boxPlot;
    });

    var boxPlot$3 = (function () {
      var base = boxPlotBase();
      var pathGenerator = shapeBoxPlot().value(0);

      var boxPlot = function boxPlot(data) {
        var filteredData = data.filter(base.defined());
        var context = pathGenerator.context();
        pathGenerator.orient(base.orient());
        filteredData.forEach(function (d, i) {
          context.save();
          var values = base.values(d, i);
          context.translate(values.origin[0], values.origin[1]);
          context.beginPath();
          context.fillStyle = colors.gray;
          context.strokeStyle = colors.black;
          base.decorate()(context, d, i);
          pathGenerator.median(values.median).upperQuartile(values.upperQuartile).lowerQuartile(values.lowerQuartile).high(values.high).width(values.width).low(values.low)([d]);
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      rebindAll(boxPlot, base);
      rebind(boxPlot, pathGenerator, 'cap', 'context');
      return boxPlot;
    });

    var boxPlot$4 = (function () {
      var base = boxPlotBase();
      var crossValueAttribute = webglElementAttribute();
      var highValueAttribute = webglElementAttribute();
      var upperQuartileValueAttribute = webglElementAttribute();
      var medianValueAttribute = webglElementAttribute();
      var lowerQuartileValueAttribute = webglElementAttribute();
      var lowValueAttribute = webglElementAttribute();
      var bandwidthAttribute = webglElementAttribute().type(types.UNSIGNED_SHORT);
      var capAttribute = webglElementAttribute().type(types.UNSIGNED_SHORT);
      var definedAttribute = webglElementAttribute().type(types.UNSIGNED_BYTE);
      var draw = webglSeriesBoxPlot().crossValueAttribute(crossValueAttribute).highValueAttribute(highValueAttribute).upperQuartileValueAttribute(upperQuartileValueAttribute).medianValueAttribute(medianValueAttribute).lowerQuartileValueAttribute(lowerQuartileValueAttribute).lowValueAttribute(lowValueAttribute).bandwidthAttribute(bandwidthAttribute).capAttribute(capAttribute).definedAttribute(definedAttribute);

      var equals = function equals(previousData, data) {
        return false;
      };

      var previousData = [];
      var cap = functor(20);

      var boxPlot = function boxPlot(data) {
        if (base.orient() !== 'vertical') {
          throw new Error("Unsupported orientation ".concat(base.orient()));
        }

        var xScale = webglScaleMapper(base.xScale());
        var yScale = webglScaleMapper(base.yScale());

        if (!isIdentityScale(xScale.scale) || !isIdentityScale(yScale.scale) || !equals(previousData, data)) {
          previousData = data;
          crossValueAttribute.value(function (d, i) {
            return xScale.scale(base.crossValue()(d, i));
          }).data(data);
          highValueAttribute.value(function (d, i) {
            return yScale.scale(base.highValue()(d, i));
          }).data(data);
          upperQuartileValueAttribute.value(function (d, i) {
            return yScale.scale(base.upperQuartileValue()(d, i));
          }).data(data);
          medianValueAttribute.value(function (d, i) {
            return yScale.scale(base.medianValue()(d, i));
          }).data(data);
          lowerQuartileValueAttribute.value(function (d, i) {
            return yScale.scale(base.lowerQuartileValue()(d, i));
          }).data(data);
          lowValueAttribute.value(function (d, i) {
            return yScale.scale(base.lowValue()(d, i));
          }).data(data);
          bandwidthAttribute.value(function (d, i) {
            return base.bandwidth()(d, i);
          }).data(data);
          capAttribute.value(function (d, i) {
            return cap(d, i);
          }).data(data);
          definedAttribute.value(function (d, i) {
            return base.defined()(d, i);
          }).data(data);
        }

        draw.xScale(xScale.glScale).yScale(yScale.glScale).decorate(function (program) {
          return base.decorate()(program, data, 0);
        });
        draw(data.length);
      };

      boxPlot.cap = function () {
        if (!arguments.length) {
          return cap;
        }

        cap = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return boxPlot;
      };

      boxPlot.equals = function () {
        if (!arguments.length) {
          return equals;
        }

        equals = arguments.length <= 0 ? undefined : arguments[0];
        return boxPlot;
      };

      rebindAll(boxPlot, base, exclude('align'));
      rebind(boxPlot, draw, 'context', 'lineWidth');
      return boxPlot;
    });

    var ohlc$2 = (function () {
      return ohlcBase$1(shapeOhlc(), 'ohlc');
    });

    var ohlc$3 = (function () {
      return ohlcBase$2(shapeOhlc());
    });

    var ohlc$4 = (function () {
      return ohlcBase$3(webglSeriesOhlc());
    });

    var multiBase = (function () {
      var series = [];

      var mapping = function mapping(d) {
        return d;
      };

      var key = function key(_, i) {
        return i;
      };

      var multi = createBase({
        decorate: function decorate() {},
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity()
      });

      multi.xValues = function () {
        return series.map(function (s) {
          return s.xValues();
        }).reduce(function (a, b) {
          return a.concat(b);
        });
      };

      multi.yValues = function () {
        return series.map(function (s) {
          return s.yValues();
        }).reduce(function (a, b) {
          return a.concat(b);
        });
      };

      multi.mapping = function () {
        if (!arguments.length) {
          return mapping;
        }

        mapping = arguments.length <= 0 ? undefined : arguments[0];
        return multi;
      };

      multi.key = function () {
        if (!arguments.length) {
          return key;
        }

        key = arguments.length <= 0 ? undefined : arguments[0];
        return multi;
      };

      multi.series = function () {
        if (!arguments.length) {
          return series;
        }

        series = arguments.length <= 0 ? undefined : arguments[0];
        return multi;
      };

      return multi;
    });

    var multiSeries = (function () {
      var base = multiBase();
      var innerJoin = dataJoin('g');
      var join = dataJoin('g', 'multi');

      var multi = function multi(selection) {
        if (selection.selection) {
          join.transition(selection);
          innerJoin.transition(selection);
        }

        var mapping = base.mapping();
        var series = base.series();
        var xScale = base.xScale();
        var yScale = base.yScale();
        selection.each(function (data, index, group) {
          var container = join(d3Selection.select(group[index]), series); // iterate over the containers, 'call'-ing the series for each

          container.each(function (dataSeries, seriesIndex, seriesGroup) {
            dataSeries.xScale(xScale).yScale(yScale);
            var seriesData = mapping(data, seriesIndex, series);
            var innerContainer = innerJoin(d3Selection.select(seriesGroup[seriesIndex]), [seriesData]);
            innerContainer.call(dataSeries);
          });
          var unwrappedSelection = container.selection ? container.selection() : container;
          unwrappedSelection.order();
          base.decorate()(container, data, index);
        });
      };

      rebindAll(multi, base);
      rebind(multi, join, 'key');
      return multi;
    });

    var multiSeries$1 = (function () {
      var context = null;
      var base = multiBase();

      var multi = function multi(data) {
        var mapping = base.mapping();
        var series = base.series();
        var xScale = base.xScale();
        var yScale = base.yScale();
        series.forEach(function (dataSeries, index) {
          var seriesData = mapping(data, index, series);
          dataSeries.context(context).xScale(xScale).yScale(yScale);
          var adaptedDecorate;

          if (dataSeries.decorate) {
            adaptedDecorate = dataSeries.decorate();
            dataSeries.decorate(function (c, d, i) {
              base.decorate()(c, data, index);
              adaptedDecorate(c, d, i);
            });
          } else {
            base.decorate()(context, data, index);
          }

          dataSeries(seriesData);

          if (adaptedDecorate) {
            dataSeries.decorate(adaptedDecorate);
          }
        });
      };

      multi.context = function () {
        if (!arguments.length) {
          return context;
        }

        context = arguments.length <= 0 ? undefined : arguments[0];
        return multi;
      };

      rebindAll(multi, base);
      return multi;
    });

    var groupedBase = (function (series) {
      var bandwidth = function bandwidth() {
        return 50;
      };

      var align = 'center'; // the offset scale is used to offset each of the series within a group

      var offsetScale = d3Scale.scaleBand();
      var grouped = createBase({
        decorate: function decorate() {},
        xScale: d3Scale.scaleLinear(),
        yScale: d3Scale.scaleLinear()
      }); // the bandwidth for the grouped series can be a function of datum / index. As a result
      // the offset scale required to cluster the 'sub' series is also dependent on datum / index.
      // This function computes the offset scale for a specific datum / index of the grouped series

      grouped.offsetScaleForDatum = function (data, d, i) {
        var width = bandwidth(d, i);
        var offset = alignOffset(align, width);
        var halfWidth = width / 2;
        return offsetScale.domain(d3Array.range(0, data.length)).range([-halfWidth + offset, halfWidth + offset]);
      };

      grouped.bandwidth = function () {
        if (!arguments.length) {
          return bandwidth;
        }

        bandwidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return grouped;
      };

      grouped.align = function () {
        if (!arguments.length) {
          return align;
        }

        align = arguments.length <= 0 ? undefined : arguments[0];
        return grouped;
      };

      rebindAll(grouped, offsetScale, includeMap({
        'paddingInner': 'paddingOuter'
      }));
      return grouped;
    });

    var grouped = (function (series) {
      var base = groupedBase();
      var join = dataJoin('g', 'grouped');

      var grouped = function grouped(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        selection.each(function (data, index, group) {
          var g = join(d3Selection.select(group[index]), data);
          g.enter().append('g');
          g.select('g').each(function (_, index, group) {
            var container = d3Selection.select(group[index]); // create a composite scale that applies the required offset

            var isVertical = series.orient() !== 'horizontal';

            var compositeScale = function compositeScale(d, i) {
              var offset = base.offsetScaleForDatum(data, d, i);
              var baseScale = isVertical ? base.xScale() : base.yScale();
              return baseScale(d) + offset(index) + offset.bandwidth() / 2;
            };

            if (isVertical) {
              series.xScale(compositeScale);
              series.yScale(base.yScale());
            } else {
              series.yScale(compositeScale);
              series.xScale(base.xScale());
            } // if the sub-series has a bandwidth, set this from the offset scale


            if (series.bandwidth) {
              series.bandwidth(function (d, i) {
                return base.offsetScaleForDatum(data, d, i).bandwidth();
              });
            } // adapt the decorate function to give each series the correct index


            series.decorate(function (s, d) {
              return base.decorate()(s, d, index);
            });
            container.call(series);
          });
        });
      };

      rebindAll(grouped, series, exclude('decorate', 'xScale', 'yScale'));
      rebindAll(grouped, base, exclude('offsetScaleForDatum'));
      return grouped;
    });

    function grouped$1 (series) {
      var base = groupedBase();

      var grouped = function grouped(data) {
        data.forEach(function (seriesData, index) {
          // create a composite scale that applies the required offset
          var isVertical = series.orient() !== 'horizontal';

          var compositeScale = function compositeScale(d, i) {
            var offset = base.offsetScaleForDatum(data, d, i);
            var baseScale = isVertical ? base.xScale() : base.yScale();
            return baseScale(d) + offset(index) + offset.bandwidth() / 2;
          };

          if (isVertical) {
            series.xScale(compositeScale);
            series.yScale(base.yScale());
          } else {
            series.yScale(compositeScale);
            series.xScale(base.xScale());
          } // if the sub-series has a bandwidth, set this from the offset scale


          if (series.bandwidth) {
            series.bandwidth(function (d, i) {
              return base.offsetScaleForDatum(data, d, i).bandwidth();
            });
          } // adapt the decorate function to give each series the correct index


          series.decorate(function (c, d) {
            return base.decorate()(c, d, index);
          });
          series(seriesData);
        });
      };

      rebindAll(grouped, series, exclude('decorate', 'xScale', 'yScale'));
      rebindAll(grouped, base, exclude('offsetScaleForDatum'));
      return grouped;
    }

    var repeat = (function () {
      var orient = 'vertical';
      var series = line();
      var multi = multiSeries();

      var repeat = function repeat(selection) {
        return selection.each(function (data, index, group) {
          if (orient === 'vertical') {
            multi.series(data[0].map(function (_) {
              return series;
            })).mapping(function (data, index) {
              return data.map(function (d) {
                return d[index];
              });
            });
          } else {
            multi.series(data.map(function (_) {
              return series;
            })).mapping(function (data, index) {
              return data[index];
            });
          }

          d3Selection.select(group[index]).call(multi);
        });
      };

      repeat.series = function () {
        if (!arguments.length) {
          return series;
        }

        series = arguments.length <= 0 ? undefined : arguments[0];
        return repeat;
      };

      repeat.orient = function () {
        if (!arguments.length) {
          return orient;
        }

        orient = arguments.length <= 0 ? undefined : arguments[0];
        return repeat;
      };

      rebindAll(repeat, multi, exclude('series', 'mapping'));
      return repeat;
    });

    var repeat$1 = (function () {
      var orient = 'vertical';
      var series = line$1();
      var multi = multiSeries$1();

      var repeat = function repeat(data) {
        if (orient === 'vertical') {
          multi.series(data[0].map(function (_) {
            return series;
          })).mapping(function (data, index) {
            return data.map(function (d) {
              return d[index];
            });
          });
        } else {
          multi.series(data.map(function (_) {
            return series;
          })).mapping(function (data, index) {
            return data[index];
          });
        }

        multi(data);
      };

      repeat.series = function () {
        if (!arguments.length) {
          return series;
        }

        series = arguments.length <= 0 ? undefined : arguments[0];
        return repeat;
      };

      repeat.orient = function () {
        if (!arguments.length) {
          return orient;
        }

        orient = arguments.length <= 0 ? undefined : arguments[0];
        return repeat;
      };

      rebindAll(repeat, multi, exclude('series', 'mapping'));
      return repeat;
    });

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

        return arr2;
      }
    }

    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }

    var sortUnique = function sortUnique(arr) {
      return arr.sort(d3Array.ascending).filter(function (value, index, self) {
        return self.indexOf(value, index + 1) === -1;
      });
    };

    var autoBandwidth = (function (adaptee) {
      var widthFraction = 0.75; // computes the bandwidth as a fraction of the smallest distance between the datapoints

      var computeBandwidth = function computeBandwidth(screenValues) {
        // return some default value if there are not enough datapoints to compute the width
        if (screenValues.length <= 1) {
          return 10;
        }

        screenValues = sortUnique(screenValues); // compute the distance between neighbouring items

        var neighbourDistances = d3Array.pairs(screenValues).map(function (tuple) {
          return Math.abs(tuple[0] - tuple[1]);
        });
        var minDistance = d3Array.min(neighbourDistances);
        return widthFraction * minDistance;
      };

      var determineBandwith = function determineBandwith(crossScale, data, accessor) {
        // if the cross-scale has a bandwidth function, i.e. it is a scaleBand, use
        // this to determine the width
        if (crossScale.bandwidth) {
          return crossScale.bandwidth();
        } else {
          var _ref;

          // grouped series expect a nested array, which is flattened out
          var flattenedData = Array.isArray(data) ? (_ref = []).concat.apply(_ref, _toConsumableArray(data)) : data; // obtain an array of points along the crossValue axis, mapped to screen coordinates.

          var crossValuePoints = flattenedData.filter(adaptee.defined()).map(accessor()).map(crossScale);
          var width = computeBandwidth(crossValuePoints);
          return width;
        }
      };

      var autoBandwidth = function autoBandwidth(arg) {
        var computeWidth = function computeWidth(data) {
          if (adaptee.xBandwidth && adaptee.yBandwidth) {
            adaptee.xBandwidth(determineBandwith(adaptee.xScale(), data, adaptee.xValue));
            adaptee.yBandwidth(determineBandwith(adaptee.yScale(), data, adaptee.yValue));
          } else {
            // if the series has an orient property, use this to determine the cross-scale, otherwise
            // assume it is the x-scale
            var crossScale = adaptee.orient && adaptee.orient() === 'horizontal' ? adaptee.yScale() : adaptee.xScale();
            adaptee.bandwidth(determineBandwith(crossScale, data, adaptee.crossValue));
          }
        };

        if (arg instanceof d3Selection.selection) {
          arg.each(function (data, index, group) {
            computeWidth(data);
            adaptee(d3Selection.select(group[index]));
          });
        } else {
          computeWidth(arg);
          adaptee(arg);
        }
      };

      rebindAll(autoBandwidth, adaptee);

      autoBandwidth.widthFraction = function () {
        if (!arguments.length) {
          return widthFraction;
        }

        widthFraction = arguments.length <= 0 ? undefined : arguments[0];
        return autoBandwidth;
      };

      return autoBandwidth;
    });

    var heatmapBase = (function () {
      var xValue = function xValue(d) {
        return d.x;
      };

      var yValue = function yValue(d) {
        return d.y;
      };

      var colorValue = function colorValue(d) {
        return d.color;
      };

      var yBandwidth = function yBandwidth() {
        return 5;
      };

      var xBandwidth = function xBandwidth() {
        return 5;
      };

      var colorInterpolate = d3Scale.interpolateViridis;
      var heatmap = createBase({
        decorate: function decorate() {},
        defined: function defined$1(d, i) {
          return defined(xValue, yValue, colorValue)(d, i);
        },
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity()
      });
      heatmap.pathGenerator = shapeBar().x(0).y(0);

      heatmap.colorScale = function (data) {
        var colorValues = data.map(colorValue); // a scale that maps the color values onto a unit range, [0, 1]

        return d3Scale.scaleLinear().domain([d3Array.min(colorValues), d3Array.max(colorValues)]);
      };

      heatmap.values = function (d, i) {
        return {
          x: heatmap.xScale()(xValue(d, i)),
          y: heatmap.yScale()(yValue(d, i)),
          colorValue: colorValue(d, i),
          width: xBandwidth(d, i),
          height: yBandwidth(d, i)
        };
      };

      heatmap.xValues = function () {
        return [xValue];
      };

      heatmap.yValues = function () {
        return [yValue];
      };

      heatmap.xValue = function () {
        if (!arguments.length) {
          return xValue;
        }

        xValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return heatmap;
      };

      heatmap.yValue = function () {
        if (!arguments.length) {
          return yValue;
        }

        yValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return heatmap;
      };

      heatmap.colorValue = function () {
        if (!arguments.length) {
          return colorValue;
        }

        colorValue = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return heatmap;
      };

      heatmap.colorInterpolate = function () {
        if (!arguments.length) {
          return colorInterpolate;
        }

        colorInterpolate = arguments.length <= 0 ? undefined : arguments[0];
        return heatmap;
      };

      heatmap.xBandwidth = function () {
        if (!arguments.length) {
          return xBandwidth;
        }

        xBandwidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return heatmap;
      };

      heatmap.yBandwidth = function () {
        if (!arguments.length) {
          return yBandwidth;
        }

        yBandwidth = functor(arguments.length <= 0 ? undefined : arguments[0]);
        return heatmap;
      };

      rebindAll(heatmap, heatmap.pathGenerator, includeMap({
        'horizontalAlign': 'xAlign',
        'verticalAlign': 'yAlign'
      }));
      return heatmap;
    });

    var heatmap = (function () {
      var base = heatmapBase();
      var join = dataJoin('g', 'box');

      var containerTransform = function containerTransform(values) {
        return 'translate(' + values.x + ', ' + values.y + ')';
      };

      var heatmap = function heatmap(selection) {
        selection.each(function (data, index, group) {
          var filteredData = data.filter(base.defined());
          var colorValue = base.colorValue();
          var colorInterpolate = base.colorInterpolate();
          var colorScale = base.colorScale(filteredData);
          var g = join(d3Selection.select(group[index]), filteredData);
          g.enter().append('path').attr('stroke', 'transparent');
          g.attr('transform', function (d, i) {
            return containerTransform(base.values(d, i));
          }).select('path').attr('d', function (d, i) {
            return base.pathGenerator.width(base.values(d, i).width).height(base.values(d, i).height)([d]);
          }).attr('fill', function (d, i) {
            return colorInterpolate(colorScale(colorValue(d, i)));
          });
          base.decorate()(g, data, index);
        });
      };

      rebindAll(heatmap, base);
      return heatmap;
    });

    var heatmap$1 = (function () {
      var base = heatmapBase();

      var heatmap = function heatmap(data) {
        var filteredData = data.filter(base.defined());
        var colorInterpolate = base.colorInterpolate();
        var colorScale = base.colorScale(filteredData);
        var context = base.pathGenerator.context();
        filteredData.forEach(function (d, i) {
          context.save();
          context.beginPath();
          var values = base.values(d, i);
          context.translate(values.x, values.y);
          context.fillStyle = colorInterpolate(colorScale(values.colorValue));
          context.strokeStyle = 'transparent';
          base.decorate()(context, d, i);
          base.pathGenerator.height(values.height).width(values.width)([d]);
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      rebind(heatmap, base.pathGenerator, 'context');
      rebindAll(heatmap, base);
      return heatmap;
    });

    exports.autoBandwidth = autoBandwidth;
    exports.seriesCanvasArea = area$3;
    exports.seriesCanvasBar = bar$3;
    exports.seriesCanvasBoxPlot = boxPlot$3;
    exports.seriesCanvasCandlestick = candlestick$3;
    exports.seriesCanvasErrorBar = errorBar$3;
    exports.seriesCanvasGrouped = grouped$1;
    exports.seriesCanvasHeatmap = heatmap$1;
    exports.seriesCanvasLine = line$1;
    exports.seriesCanvasMulti = multiSeries$1;
    exports.seriesCanvasOhlc = ohlc$3;
    exports.seriesCanvasPoint = point$1;
    exports.seriesCanvasRepeat = repeat$1;
    exports.seriesSvgArea = area$2;
    exports.seriesSvgBar = bar$2;
    exports.seriesSvgBoxPlot = boxPlot$2;
    exports.seriesSvgCandlestick = candlestick$2;
    exports.seriesSvgErrorBar = errorBar$2;
    exports.seriesSvgGrouped = grouped;
    exports.seriesSvgHeatmap = heatmap;
    exports.seriesSvgLine = line;
    exports.seriesSvgMulti = multiSeries;
    exports.seriesSvgOhlc = ohlc$2;
    exports.seriesSvgPoint = point;
    exports.seriesSvgRepeat = repeat;
    exports.seriesWebglArea = area$4;
    exports.seriesWebglBar = bar$4;
    exports.seriesWebglBoxPlot = boxPlot$4;
    exports.seriesWebglCandlestick = candlestick$4;
    exports.seriesWebglErrorBar = errorBar$4;
    exports.seriesWebglLine = line$3;
    exports.seriesWebglMulti = multiSeries$1;
    exports.seriesWebglOhlc = ohlc$4;
    exports.seriesWebglPoint = point$2;
    exports.seriesWebglRepeat = repeat$1;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
